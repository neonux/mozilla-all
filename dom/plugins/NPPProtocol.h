//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef mozilla_plugins_NPPProtocol_h
#define mozilla_plugins_NPPProtocol_h

#include "base/basictypes.h"
#include "nscore.h"
#include "IPC/IPCMessageUtils.h"
#include "mozilla/ipc/MessageTypes.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "PluginMessageUtils.h"
#include "mozilla/plugins/NPAPIProtocol.h"

namespace mozilla {
namespace plugins {
namespace NPPProtocol {


enum State {
};

enum NPPProtocolMsgType {
    NPPProtocolStart = NPPProtocolMsgStart << 12,
    NPPProtocolPreStart = (NPPProtocolMsgStart << 12) - 1,
    Msg_NPP_SetWindow__ID,
    Reply_NPP_SetWindow__ID,
    Msg_NPP_GetValue__ID,
    Reply_NPP_GetValue__ID,
    Msg_NPN_GetValue__ID,
    Reply_NPN_GetValue__ID,
    NPPProtocolEnd
};
class Msg_NPP_SetWindow :
    public IPC::Message
{
private:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

public:
    enum {
        ID = Msg_NPP_SetWindow__ID
    };
    Msg_NPP_SetWindow(const NPWindow& window) :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
    {
        IPC::WriteParam(this, window);
    }

    static bool Read(
                const Message* msg,
                NPWindow* window)
    {
        void* iter = 0;

        if (!(IPC::ReadParam(msg, &(iter), window))) {
            return false;
        }

        return true;
    }
};
class Reply_NPP_SetWindow :
    public IPC::Message
{
private:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

public:
    enum {
        ID = Reply_NPP_SetWindow__ID
    };
    Reply_NPP_SetWindow(const NPError& rv) :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
    {
        IPC::WriteParam(this, rv);
    }

    static bool Read(
                const Message* msg,
                NPError* rv)
    {
        void* iter = 0;

        if (!(IPC::ReadParam(msg, &(iter), rv))) {
            return false;
        }

        return true;
    }
};
class Msg_NPP_GetValue :
    public IPC::Message
{
private:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

public:
    enum {
        ID = Msg_NPP_GetValue__ID
    };
    Msg_NPP_GetValue(const String& key) :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
    {
        IPC::WriteParam(this, key);
    }

    static bool Read(
                const Message* msg,
                String* key)
    {
        void* iter = 0;

        if (!(IPC::ReadParam(msg, &(iter), key))) {
            return false;
        }

        return true;
    }
};
class Reply_NPP_GetValue :
    public IPC::Message
{
private:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

public:
    enum {
        ID = Reply_NPP_GetValue__ID
    };
    Reply_NPP_GetValue(const String& value) :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
    {
        IPC::WriteParam(this, value);
    }

    static bool Read(
                const Message* msg,
                String* value)
    {
        void* iter = 0;

        if (!(IPC::ReadParam(msg, &(iter), value))) {
            return false;
        }

        return true;
    }
};
class Msg_NPN_GetValue :
    public IPC::Message
{
private:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

public:
    enum {
        ID = Msg_NPN_GetValue__ID
    };
    Msg_NPN_GetValue(const String& key) :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
    {
        IPC::WriteParam(this, key);
    }

    static bool Read(
                const Message* msg,
                String* key)
    {
        void* iter = 0;

        if (!(IPC::ReadParam(msg, &(iter), key))) {
            return false;
        }

        return true;
    }
};
class Reply_NPN_GetValue :
    public IPC::Message
{
private:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

public:
    enum {
        ID = Reply_NPN_GetValue__ID
    };
    Reply_NPN_GetValue(const String& value) :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
    {
        IPC::WriteParam(this, value);
    }

    static bool Read(
                const Message* msg,
                String* value)
    {
        void* iter = 0;

        if (!(IPC::ReadParam(msg, &(iter), value))) {
            return false;
        }

        return true;
    }
};


} // namespace NPPProtocol
} // namespace plugins
} // namespace mozilla

#endif // ifndef mozilla_plugins_NPPProtocol_h

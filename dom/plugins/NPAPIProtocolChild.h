//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef mozilla_plugins_NPAPIProtocolChild_h
#define mozilla_plugins_NPAPIProtocolChild_h

#include "mozilla/plugins/NPAPIProtocol.h"
#include "mozilla/plugins/NPPProtocolChild.h"
#include "base/id_map.h"
#include "mozilla/ipc/RPCChannel.h"

namespace mozilla {
namespace plugins {


class /*NS_ABSTRACT_CLASS*/ NPAPIProtocolChild :
    public mozilla::ipc::RPCChannel::Listener,
    public mozilla::ipc::IProtocolManager
{
protected:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

    virtual nsresult AnswerNP_Initialize(NPError* rv) = 0;
    virtual NPPProtocolChild* NPPConstructor(
                const String& aMimeType,
                const uint16_t& aMode,
                const StringArray& aNames,
                const StringArray& aValues,
                NPError* rv) = 0;
    virtual nsresult NPPDestructor(
                NPPProtocolChild* __a,
                NPError* rv) = 0;

private:
    typedef IPC::Message Message;
    typedef mozilla::ipc::RPCChannel Channel;

public:
    NPAPIProtocolChild() :
        mChannel(this)
    {
    }

    virtual ~NPAPIProtocolChild()
    {
    }

    bool Open(
                IPC::Channel* aChannel,
                MessageLoop* aThread = 0)
    {
        return mChannel.Open(aChannel, aThread);
    }

    void Close()
    {
        mChannel.Close();
    }

    virtual Result OnMessageReceived(const Message& msg)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual Result OnMessageReceived(
                const Message& msg,
                Message*& reply)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual Result OnCallReceived(
                const Message& msg,
                Message*& reply)
    {
        int __route;
        __route = msg.routing_id();
        if ((MSG_ROUTING_CONTROL) != (__route)) {
            Channel::Listener* __routed;
            __routed = Lookup(__route);
            if (!(__routed)) {
                return MsgRouteError;
            }
            return __routed->OnCallReceived(msg, reply);
        }

        switch (msg.type()) {
        case NPAPIProtocol::Msg_NP_Initialize__ID:
            {
                NPError rv;

                if (!(NPAPIProtocol::Msg_NP_Initialize::Read(&(msg)))) {
                    return MsgPayloadError;
                }
                if (AnswerNP_Initialize(&(rv))) {
                    return MsgValueError;
                }

                reply = new NPAPIProtocol::Reply_NP_Initialize(rv);
                reply->set_reply();
                return MsgProcessed;
            }
        case NPAPIProtocol::Msg_NPPConstructor__ID:
            {
                String aMimeType;
                uint16_t aMode;
                StringArray aNames;
                StringArray aValues;
                NPError rv;
                mozilla::ipc::ActorHandle __ah;

                if (!(NPAPIProtocol::Msg_NPPConstructor::Read(&(msg), &(aMimeType), &(aMode), &(aNames), &(aValues), &(__ah)))) {
                    return MsgPayloadError;
                }

                NPPProtocolChild* __a;
                __a = NPPConstructor(aMimeType, aMode, aNames, aValues, &(rv));
                if (!(__a)) {
                    return MsgValueError;
                }

                __ah.mChildId = __a->mId = Register(__a);
                __a->mPeerId = __ah.mParentId;
                __a->mManager = this;
                __a->mChannel = &(mChannel);

                reply = new NPAPIProtocol::Reply_NPPConstructor(rv, __ah);
                reply->set_reply();
                return MsgProcessed;
            }
        case NPAPIProtocol::Msg_NPPDestructor__ID:
            {
                NPError rv;
                mozilla::ipc::ActorHandle __ah;

                if (!(NPAPIProtocol::Msg_NPPDestructor::Read(&(msg), &(__ah)))) {
                    return MsgPayloadError;
                }
                NPPProtocolChild* __a;
                __a = static_cast<NPPProtocolChild*>(Lookup(__ah.mChildId));
                if (!(__a)) {
                    return MsgValueError;
                }
                if (NPPDestructor(__a, &(rv))) {
                    return MsgValueError;
                }
                Unregister(__ah.mChildId);
                __ah.mChildId = -1;

                reply = new NPAPIProtocol::Reply_NPPDestructor(rv, __ah);
                reply->set_reply();
                return MsgProcessed;
            }
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual int32 Register(Channel::Listener* aRouted)
    {
        return mActorMap.Add(aRouted);
    }
    virtual Channel::Listener* Lookup(int32 aId)
    {
        return mActorMap.Lookup(aId);
    }
    virtual void Unregister(int32 aId)
    {
        return mActorMap.Remove(aId);
    }

private:
    Channel mChannel;
    IDMap<Channel::Listener> mActorMap;
};


} // namespace plugins
} // namespace mozilla

#endif // ifndef mozilla_plugins_NPAPIProtocolChild_h

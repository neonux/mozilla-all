//
// Automatically generated by ipdlc.
// Edit at your own risk.
//
#include "IFrameEmbeddingProtocol.h"

#include "mozilla/ipc/RPCChannel.h"
using mozilla::ipc::RPCChannel;
using IPC::Message;

class NS_FINAL_CLASS IFrameEmbeddingProtocolChild :
    public IFrameEmbeddingProtocol::Parent,
    public RPCChannel::Listener
{
public:
    IFrameEmbeddingProtocolChild(IFrameEmbeddingProtocol::Child* aChild) :
        mChild(aChild),
        mRpc(this)
    { }

    bool Open(IPC::Channel* aChannel, MessageLoop* aIOLoop)
    {
        return mRpc.Open(aChannel, aIOLoop);
    }

    void Close()
    {
        mRpc.Close();
    }

    virtual Result OnCallReceived(const Message& msg, Message** reply)
    {
        switch (msg.type()) {
        case IFrameEmbedding_ParentToChildMsg_init__ID: {
            MagicWindowHandle parentWidget;
            MagicWindowHandle p;
            IFrameEmbedding_ParentToChildMsg_init::Read(&msg, &p);

            parentWidget = p;

            nsresult _rv = mChild->init(
                parentWidget);
            *reply = new IFrameEmbedding_ChildToParentMsg_Reply_init();
            (*reply)->set_reply();
            return MsgProcessed;
        }
        case IFrameEmbedding_ParentToChildMsg_loadURL__ID: {
            String uri;
            String p;
            IFrameEmbedding_ParentToChildMsg_loadURL::Read(&msg, &p);

            uri = p;

            nsresult _rv = mChild->loadURL(
                uri);
            *reply = new IFrameEmbedding_ChildToParentMsg_Reply_loadURL();
            (*reply)->set_reply();
            return MsgProcessed;
        }
        case IFrameEmbedding_ParentToChildMsg_move__ID: {
            uint32_t x;
            uint32_t y;
            uint32_t width;
            uint32_t height;
            IFrameEmbedding_ParentToChildMsg_move::Param p;
            IFrameEmbedding_ParentToChildMsg_move::Read(&msg, &p);

            x = p.a;
            y = p.b;
            width = p.c;
            height = p.d;

            nsresult _rv = mChild->move(
                x, y, width, height);
            *reply = new IFrameEmbedding_ChildToParentMsg_Reply_move();
            (*reply)->set_reply();
            return MsgProcessed;
        }
        default: {
            return MsgNotKnown;
        }
        }
    }

private:
    IFrameEmbeddingProtocol::Child* mChild;
    RPCChannel mRpc;
};

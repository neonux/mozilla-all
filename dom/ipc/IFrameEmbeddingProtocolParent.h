//
// Automatically generated by ipdlc.
// Edit at your own risk.
//
#include "IFrameEmbeddingProtocol.h"

#include "mozilla/ipc/RPCChannel.h"
using mozilla::ipc::RPCChannel;
using IPC::Message;

class NS_FINAL_CLASS IFrameEmbeddingProtocolParent :
    public IFrameEmbeddingProtocol::Child,
    public RPCChannel::Listener
{
public:
    IFrameEmbeddingProtocolParent(IFrameEmbeddingProtocol::Parent* aParent) :
        mParent(aParent),
        mRpc(this)
    { }

    bool Open(IPC::Channel* aChannel)
    {
        return mRpc.Open(aChannel);
    }

    void Close()
    {
        mRpc.Close();
    }

    virtual nsresult init(
        const MagicWindowHandle& parentWidget)
    {
        Message reply;
        nsresult _rv = mRpc.Call(new IFrameEmbedding_ParentToChildMsg_init(
            parentWidget)
            , &reply);

        if (NS_OK == _rv) {
        }
        return _rv;
    }

    virtual nsresult loadURL(
        const String& uri)
    {
        Message reply;
        nsresult _rv = mRpc.Call(new IFrameEmbedding_ParentToChildMsg_loadURL(
            uri)
            , &reply);

        if (NS_OK == _rv) {
        }
        return _rv;
    }

    virtual nsresult move(
        const uint32_t& x, const uint32_t& y, const uint32_t& width, const uint32_t& height)
    {
        Message reply;
        nsresult _rv = mRpc.Call(new IFrameEmbedding_ParentToChildMsg_move(
            x, y, width, height)
            , &reply);

        if (NS_OK == _rv) {
        }
        return _rv;
    }

    virtual Result OnCallReceived(const Message& msg, Message** reply)
    {
        switch (msg.type()) {
        default: {
            return MsgNotKnown;
        }
        }
    }

private:
    IFrameEmbeddingProtocol::Parent* mParent;
    RPCChannel mRpc;
};

//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef IFrameEmbeddingProtocolParent_h
#define IFrameEmbeddingProtocolParent_h

#include "IFrameEmbeddingProtocol.h"
#include "mozilla/ipc/RPCChannel.h"



class /*NS_ABSTRACT_CLASS*/ IFrameEmbeddingProtocolParent :
    public mozilla::ipc::RPCChannel::Listener
{
protected:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;


private:
    typedef IPC::Message Message;
    typedef mozilla::ipc::RPCChannel Channel;

public:
    IFrameEmbeddingProtocolParent() :
        mChannel(this)
    {
    }

    virtual ~IFrameEmbeddingProtocolParent()
    {
    }

    bool Open(
                IPC::Channel* aChannel,
                MessageLoop* aThread = 0)
    {
        return mChannel.Open(aChannel, aThread);
    }

    void Close()
    {
        mChannel.Close();
    }

    nsresult Callinit(const MagicWindowHandle& parentWidget)
    {
        Message __reply;
        Message* __msg;
        __msg = new IFrameEmbeddingProtocol::Msg_init(parentWidget);
        __msg->set_routing_id(MSG_ROUTING_CONTROL);
        if (!(mChannel.Call(__msg, &(__reply)))) {
            return NS_ERROR_FAILURE;
        }
        if (!(IFrameEmbeddingProtocol::Reply_init::Read(&(__reply)))) {
            return NS_ERROR_ILLEGAL_VALUE;
        }
        return NS_OK;
    }

    nsresult CallloadURL(const String& uri)
    {
        Message __reply;
        Message* __msg;
        __msg = new IFrameEmbeddingProtocol::Msg_loadURL(uri);
        __msg->set_routing_id(MSG_ROUTING_CONTROL);
        if (!(mChannel.Call(__msg, &(__reply)))) {
            return NS_ERROR_FAILURE;
        }
        if (!(IFrameEmbeddingProtocol::Reply_loadURL::Read(&(__reply)))) {
            return NS_ERROR_ILLEGAL_VALUE;
        }
        return NS_OK;
    }

    nsresult Callmove(
                const PRUint32& x,
                const PRUint32& y,
                const PRUint32& width,
                const PRUint32& height)
    {
        Message __reply;
        Message* __msg;
        __msg = new IFrameEmbeddingProtocol::Msg_move(x, y, width, height);
        __msg->set_routing_id(MSG_ROUTING_CONTROL);
        if (!(mChannel.Call(__msg, &(__reply)))) {
            return NS_ERROR_FAILURE;
        }
        if (!(IFrameEmbeddingProtocol::Reply_move::Read(&(__reply)))) {
            return NS_ERROR_ILLEGAL_VALUE;
        }
        return NS_OK;
    }

    virtual Result OnMessageReceived(const Message& msg)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual Result OnMessageReceived(
                const Message& msg,
                Message*& reply)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual Result OnCallReceived(
                const Message& msg,
                Message*& reply)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

private:
    Channel mChannel;
    int mId;
    int mPeerId;
    mozilla::ipc::IProtocolManager* mManager;
};


#if 0

//-----------------------------------------------------------------------------
// Skeleton implementation of abstract actor class

// Header file contents
class ActorImpl :
    public IFrameEmbeddingProtocolParent
{
    ActorImpl();
    virtual ~ActorImpl();
};


// C++ file contents
ActorImpl::ActorImpl()
{
}

ActorImpl::~ActorImpl()
{
}

#endif // if 0

#endif // ifndef IFrameEmbeddingProtocolParent_h

# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is mozilla.org code.
#
# Contributor(s):
#   Chris Jones <jones.chris.g@gmail.com>
#
# Alternatively, the contents of this file may be used under the terms of
# either of the GNU General Public License Version 2 or later (the "GPL"),
# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

import os
from copy import deepcopy

from ipdl.ast import Visitor, ASYNC, SYNC, RPC, IN, OUT, INOUT
import ipdl.cxx.ast as cxx

EMIT_LOGGING_CODE = False

def _joinProtocolNamespacesName(sep, p, pname):
    return sep.join([ ns.namespace for ns in p.namespaces ] + [ pname ])

def _protocolIncludeGuard(p, pname):
    return _joinProtocolNamespacesName('_', p, pname) +'_h'

def _protocolHeaderFilename(p, pname):
    return _joinProtocolNamespacesName('/', p, pname)+ '.h'

def _protocolHeaderName(pname):
    return pname +'Protocol'

def _makeForwardDecl(p, namesuffix=''):
    clsname = p.decl.type.qname.baseid + namesuffix
    
    fd = cxx.ForwardDecl(clsname, cls=1)
    if 0 == len(p.namespaces):
        return fd

    outerns = cxx.Namespace(p.namespaces[0].namespace)
    innerns = outerns
    for ns in p.namespaces[1:]:
        tmpns = cxx.Namespace(ns.namespace)
        innerns.addstmt(tmpns)
        innerns = tmpns

    innerns.addstmt(fd)
    return outerns

class _struct: pass

class LowerToCxx:
    def lower(self, tu):
        '''returns a list of cxx.File representing the lowered form of |tu|'''
        pname = _protocolHeaderName(tu.protocol.name)
        pheader = cxx.File(pname +'.h')
        gph = GenerateProtocolHeader()
        gph.lower(tu, pname, pheader)

        parentname = pname +'Parent'
        parentheader = cxx.File(parentname +'.h')
        GenerateProtocolParentHeader().lower(
            tu, pname, parentname, parentheader, gph.typedefs)

        childname = pname +'Child'
        childheader = cxx.File(childname +'.h')
        GenerateProtocolChildHeader().lower(
            tu, pname, childname, childheader, gph.typedefs)

        return pheader, parentheader, childheader


##-----------------------------------------------------------------------------
class GenerateProtocolHeader(Visitor):
    '''creates a "generic" protocol header from an IPDL AST'''
    def __init__(self):
        self.pname = None
        self.file = None
        self.ns = None          # the namespace we toss all this stuff into
        # list of typedefs for the protocol namespace.  these are 
        # produced from various places in the AST and collected here
        self.typedefs = [ ]

    def lower(self, tu, protocol, outcxxfile):
        self.pname = protocol
        self.file = outcxxfile
        tu.accept(self)


    def typedef(self, t, name):
        self.typedefs.append(cxx.Typedef(cxx.Type(t), cxx.Type(name)))

    def injectTypedefs(self, scope):
        for tdef in self.typedefs:
            scope.addstmt(tdef)

    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        Visitor.visitTranslationUnit(self, tu)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))


    def visitCxxInclude(self, inc):
        self.file.addthing(cxx.CppDirective('include', '"'+ inc.file +'"'))


    def visitProtocolInclude(self, inc):
        p = inc.tu.protocol
        self.file.addthing(
            cxx.CppDirective(
                'include',
                '"'+ _protocolHeaderFilename(p, _protocolHeaderName(p.name)) +'"'))


    def visitUsingStmt(self, using):
        if using.decl.fullname is not None:
            self.typedef(using.decl.fullname, using.decl.shortname)


    def visitProtocol(self, p):
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        ns = cxx.Namespace(self.pname)
        self.ns.addstmt(ns)
        self.ns = ns
        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)

        # state information
        stateenum = cxx.TypeEnum('State')
        for ts in p.transitionStmts:
            ts.accept(self)
            stateenum.addId(ts.state.decl._cxxname)
        if len(p.transitionStmts):
            startstate = p.transitionStmts[0].state.decl._cxxname
        else:
            startstate = '0'
        stateenum.addId('StateStart', startstate)
        stateenum.addId('StateError')
        stateenum.addId('StateLast')

        ns.addstmt(cxx.StmtDecl(cxx.Decl(stateenum, '')))
        ns.addstmt(cxx.Whitespace.NL)

        # previsit the messages and stash away some common info used
        # several times later
        for md in p.messageDecls:
            md.accept(self)

        # spit out message type enum and classes
        msgstart = self.pname +'MsgStart << 12'
        msgenum = cxx.TypeEnum('MessageType')
        msgenum.addId(self.pname +'Start', msgstart)
        msgenum.addId(self.pname +'PreStart', '('+ msgstart +') - 1')

        for md in p.messageDecls:
            msgenum.addId(md._cxx.id +'__ID')
            if md.decl.type.hasReply():
                msgenum.addId(md._cxx.replyid +'__ID')            

        msgenum.addId(self.pname +'End')
        ns.addstmt(cxx.StmtDecl(cxx.Decl(msgenum, '')))
        ns.addstmt(cxx.Whitespace.NL)

        for md in p.messageDecls:
            ns.addstmt(generateMessageClass(md, self.injectTypedefs))
            if md.decl.type.hasReply():
                ns.addstmt(generateReplyClass(md, self.injectTypedefs))

        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)


    def visitMessageDecl(self, md):
        # where we squirrel away some common information
        md._cxx = _struct()

        md._cxx.params = [ ]
        for param in md.inParams:
            md._cxx.params.append(cxx.Decl(cxx.Type(param.type.name()),
                                           param.progname))
        md._cxx.returns = [ ]
        for param in md.outParams:
            md._cxx.returns.append(cxx.Decl(cxx.Type(param.type.name()),
                                            param.progname))

        # generate C++ interface to message sending/handling
        method = cxx.MethodDecl(
            name=md.decl.progname,
            params=[ ],
            ret=cxx.Type('nsresult'),
            virtual=True)
        for param in md._cxx.params:
            pcopy = deepcopy(param)
            pcopy.type.const = True
            pcopy.type.ref = True
            method.params.append(pcopy)
        for ret in md._cxx.returns:
            rcopy = deepcopy(ret)
            rcopy.type.ptr = True
            method.params.append(rcopy)
        md._cxx.method = method

        # the ID is used by the IPC layer only
        md._cxx.id = 'Msg_%s'% (md.decl.progname)
        md._cxx.nsid = '%s::%s'% (self.pname, md._cxx.id)
        if md.decl.type.hasReply():
            md._cxx.replyid = 'Reply_%s'% (md.decl.progname)
            md._cxx.nsreplyid = '%s::%s'% (self.pname, md._cxx.replyid)


    def visitTransitionStmt(self, ts):
        ts.state.decl._cxxname = 'State_%s__ID'% (ts.state.decl.progname)


def generateMsgClass(md, clsname, params, typedefInjector):
        cls = cxx.Class(name=clsname,
                        inherits=[ cxx.Inherit('IPC::Message') ])
        cls.addstmt(cxx.Label('private'))
        typedefInjector(cls)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('public'))

        idenum = cxx.TypeEnum()
        idenum.addId('ID', clsname +'__ID')
        cls.addstmt(cxx.StmtDecl(cxx.Decl(idenum, '')))

        # FIXME/cjones: need to handle "managed" messages

        constparams = deepcopy(params)
        writestmts = [ ]
        for cparam in constparams:
            cparam.type.const = True
            cparam.type.ref = True

        if md.decl.type.hasImplicitActorParam():
            constparams.append(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle', const=1, ref=1),
                    '__ah'))

        # make the message constructor (serializer)
        ctordecl = cxx.ConstructorDecl(clsname, params=constparams)

        superinit = cxx.ExprMemberInit(
            cxx.ExprVar('IPC::Message'),
            [ cxx.ExprVar('MSG_ROUTING_NONE'),
              cxx.ExprVar('ID'),
              cxx.ExprVar('PRIORITY_NORMAL') ])

        ctor = cxx.ConstructorDefn(ctordecl, [ superinit ])
        for cparam in constparams:
            ctor.addstmt(
                cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar('IPC::WriteParam'),
                                          [ cxx.ExprVar('this'),
                                            cxx.ExprVar(cparam.name) ])))
        cls.addstmt(ctor)

        cls.addstmt(cxx.Whitespace.NL)

        # make the message deserializer
        outparams = deepcopy(params)
        for oparam in outparams:
            oparam.type.ptr = True

        if md.decl.type.hasImplicitActorParam():
            outparams.append(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle', ptr=1),
                    '__ah'))

        reader = cxx.MethodDefn(
            cxx.MethodDecl(
                'Read',
                params=([ cxx.Decl(cxx.Type('Message', ptr=True, const=True),
                                   'msg') ]
                        + outparams),
                ret=cxx.Type('bool'),
                static=True))

        # avoid generating an unused variable when we don't deserialize
        # anything.  why generate the method anyway?  it keeps other code
        # consistent, and we might do some checking in here eventually
        if len(outparams):
            # hack
            reader.addstmt(
                cxx.StmtDecl(cxx.Decl(cxx.Type('void', ptr=True), 'iter = 0')))
            reader.addstmt(cxx.Whitespace.NL)

        for oparam in outparams:
            cond = cxx.ExprPrefixUnop(
                cxx.ExprCall(cxx.ExprVar('IPC::ReadParam'),
                             [ cxx.ExprVar('msg'),
                               cxx.ExprAddrOf(cxx.ExprVar('iter')),
                               cxx.ExprVar(oparam.name) ]),
                '!')
            ifstmt = cxx.StmtIf(cond)
            # false isn't a var
            ifstmt.addifstmt(cxx.StmtReturn(cxx.ExprVar('false')))
            reader.addstmt(ifstmt)
            reader.addstmt(cxx.Whitespace.NL)

        # false isn't a var
        reader.addstmt(cxx.StmtReturn(cxx.ExprVar('true')))

        cls.addstmt(reader)
        cls.addstmt(cxx.Whitespace.NL)

        # generate a logging function
        # 'pfx' will be something like "[FooParent] sent"
        logger = cxx.MethodDefn(
            cxx.MethodDecl(
                'Log',
                params=([ cxx.Decl(cxx.Type('std::string', const=1, ref=1),
                                   '__pfx'),
                          cxx.Decl(cxx.Type('FILE', ptr=True), '__outf') ]),
                const=1))
        pfxvar = cxx.ExprVar('__pfx')
        outfvar = cxx.ExprVar('__outf')
        # TODO/cjones: allow selecting what information is printed to 
        # the log
        logger.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('std::string'),
                                             '__logmsg')))
        msgvar = cxx.ExprVar('__logmsg')
        def appendToMsg(thing):
            logger.addstmt(cxx.StmtExpr(cxx.ExprCall(
                        cxx.ExprSelect(msgvar, '.', 'append'),
                        [ thing ])))

        # XXX/cjones: OK to stick this before prefix?
        logger.addstmt(cxx.StmtExpr(
                cxx.ExprCall(cxx.ExprVar('StringAppendF'),
                             [ cxx.ExprAddrOf(msgvar),
                               cxx.ExprLiteral.String('[time:%" PRId64 "]'),
                               cxx.ExprCall(cxx.ExprVar('PR_Now')) ])))
        appendToMsg(pfxvar)
        appendToMsg(cxx.ExprLiteral.String(md.decl.progname +'('))
        logger.addstmt(cxx.Whitespace.NL)

        # call the deserializing method we created above
        for oparam in outparams:
            oparam = deepcopy(oparam)
            oparam.type.ptr = 0
            logger.addstmt(cxx.StmtDecl(oparam))
        errif = cxx.StmtIf(cxx.ExprCall(
                    cxx.ExprVar('Read'),
                    ([ cxx.ExprVar('this') ]
                     + [ cxx.ExprAddrOf(cxx.ExprVar(p.name))
                         for p in outparams ])))
        # case where successfully deserialized message

        # XXX we have to do this string/wstring garbage because of 
        # our incompatible compilation of chromium and mozilla string
        # code with gcc
        errif.addifstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('std::wstring'), 
                                            '__param')))
        paramvar = cxx.ExprVar('__param')
        for oparam in outparams:
            # FIXME/cjones: this code doesn't work on gcc/POSIX,
            # because it wprintf()s across the chromium/mozilla boundary.
            # one side has -fshort-wchar, the other doesn't.  not
            # feasible.  either message logging needs to be rewritten, or
            # -fshort-wchar needs to be disabled (again)

            if EMIT_LOGGING_CODE:
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprVar('IPC::LogParam'),
                            [ cxx.ExprVar(oparam.name),
                              cxx.ExprAddrOf(paramvar) ])))
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(msgvar, '.', 'append'),
                            [ cxx.ExprCall(cxx.ExprVar('WideToUTF8'),
                                           [ paramvar ]) ])))
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(msgvar, '.', 'append'),
                            [ cxx.ExprLiteral.String(', ') ])))
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(paramvar, '.', 'clear'))))
            else:
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(msgvar, '.', 'append'),
                            [ cxx.ExprLiteral.String('FIXME, ') ])))

        # case where we couldn't deserialize the message
        errif.addelsestmt(cxx.StmtExpr(
                cxx.ExprCall(cxx.ExprSelect(msgvar, '.', 'append'),
                             [ cxx.ExprLiteral.String('!!INVALID MSG!!') ])))
        logger.addstmt(errif)

        logger.addstmt(cxx.Whitespace.NL)
        appendToMsg(cxx.ExprLiteral.String(')\\n'))

        # and actually print the log message
        logger.addstmt(cxx.StmtExpr(cxx.ExprCall(
                    cxx.ExprVar('fputs'),
                    [ cxx.ExprCall(cxx.ExprSelect(msgvar, '.', 'c_str')),
                      outfvar ])))

        cls.addstmt(logger)

        return cls

def generateMessageClass(md, typedefInjector):
    return generateMsgClass(md, md._cxx.id, md._cxx.params, typedefInjector)

def generateReplyClass(md, typedefInjector):
    return generateMsgClass(md, md._cxx.replyid, md._cxx.returns, typedefInjector)


##-----------------------------------------------------------------------------
_channelTable = {
    ASYNC: [ 'mozilla', 'ipc', 'AsyncChannel' ],
    SYNC: [ 'mozilla', 'ipc', 'SyncChannel' ],
    RPC: [ 'mozilla', 'ipc', 'RPCChannel' ]
}
_listenerTable = {
    ASYNC: 'AsyncListener',
    SYNC: 'SyncListener',
    RPC: 'RPCListener',
}

class GenerateProtocolActorHeader(Visitor):
    def __init__(self, myside, otherside):
        self.myside = myside  # "Parent" or "Child"
        self.otherside = otherside
        self.clsname = None
        self.pname = None
        self.file = None
        self.ns = None
        self.typedefs = None

    def lower(self, tu, pname, clsname, cxxHeaderFile, typedefs):
        self.pname = pname
        self.clsname = clsname
        self.file = cxxHeaderFile
        self.typedefs = deepcopy(typedefs)
        tu.accept(self)

    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.clsname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        mainheader = _protocolHeaderFilename(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('include', '"'+ mainheader +'"'))

        self.protocol = tu.protocol

        for pinc in tu.protocolIncludes:
            pinc.accept(self)

        tu.protocol.accept(self)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))

    def visitProtocolInclude(self, pi):
        p = pi.tu.protocol

        if self.protocol.decl.type.isManagerOf(p.decl.type):
            header = _protocolHeaderFilename(
                p, _protocolHeaderName(p.name)+ self.myside)
            self.file.addthing(cxx.CppDirective('include', '"'+ header +'"'))
        else:
            self.file.addthing(_makeForwardDecl(p, 'Protocol'+ self.myside))
            
        if p.decl.fullname is not None:
            self.typedefs.append(cxx.Typedef(
                cxx.Type(_protocolHeaderName(p.decl.fullname) + self.myside),
                cxx.Type(_protocolHeaderName(p.decl.shortname) + self.myside)))

    def visitProtocol(self, p):
        p._cxx = _struct()

        self.file.addthing(cxx.CppDirective('ifdef', 'DEBUG'))
        self.file.addthing(cxx.CppDirective('include', '"prenv.h"'))
        self.file.addthing(cxx.CppDirective('endif', '// DEBUG'))

        if p.decl.type.isManager():
            self.file.addthing(cxx.CppDirective('include', '"base/id_map.h"'))

        # bug 510041: we need to claim to implement the listener
        # interface for the top-level protocol's channel type, rather
        # for the channel type that this protocol wants
        sendsemantics = p.decl.type.toplevel().sendSemantics
        channel = _channelTable[sendsemantics]
        channellistener = _listenerTable[sendsemantics]
        channelname = '::'.join(channel)
        channelfile = '/'.join(channel) +'.h'
        if p.decl.type.isToplevel():
            self.channelsel = '.'
        else:
            self.channelsel = '->'

        self.file.addthing(cxx.CppDirective('include', '"'+ channelfile +'"'))
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)

        channellistener = channelname +'::'+ channellistener
        p._cxx.managertype = (
            'mozilla::ipc::IProtocolManager<'+ channellistener +'>')
        if p.decl.type.isToplevel():
            p._cxx.routeidvar = cxx.ExprVar('mLastRouteId')
            if self.myside is 'Parent':
                op = '++'
            else:
                op = '--'
            p._cxx.nextRouteId = cxx.ExprPrefixUnop(p._cxx.routeidvar, op)

        inherits = [ cxx.Inherit(channellistener) ]
        if p.decl.type.isManager():
            inherits.append(cxx.Inherit(p._cxx.managertype))
        cls = cxx.Class(self.clsname, inherits=inherits, abstract=True)

        if p.decl.type.isManaged():
            cls.addstmt(cxx.FriendClassDecl(
                    _protocolHeaderName(p.decl.type.manager.fullname())
                                        + self.myside))
            cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('protected'))
        for typedef in self.typedefs:
            cls.addstmt(typedef)
        cls.addstmt(cxx.Whitespace.NL)

        # constructor/destructor interface for subclass to impl
        for md in p.messageDecls:
            if md.decl.type.isCtor() or md.decl.type.isDtor():
                objtype = cxx.Type(
                    (_protocolHeaderName(md.decl.type.constructedType().name())
                     + self.myside),
                    ptr=1)
                meth = deepcopy(md._cxx.method)
                meth.pure = True
                if md.decl.type.isCtor():
                    meth.ret = objtype
                else:
                    actordecl = cxx.Decl(objtype, '__a')
                    meth.params.insert(0, actordecl)
                cls.addstmt(cxx.StmtDecl(meth))

            if self.receivesMessage(md) and not md.decl.type.isCtor():
                if md.decl.type.isRpc():  pfx = 'Answer'
                else:                     pfx = 'Recv'
                meth = deepcopy(md._cxx.method)
                meth.name = pfx + meth.name
                if md.decl.type.isDtor():
                    # allow implementations to receive a notification
                    # of "RecvDtor()" if they override this do-nothing
                    # virtual method
                    meth.params.insert(0, actordecl)
                    meth.virtual = True
                    dummyimpl = cxx.MethodDefn(meth)
                    dummyimpl.addstmt(cxx.StmtReturn(cxx.ExprVar('NS_OK')))
                    cls.addstmt(dummyimpl)
                else:
                    meth.pure = True
                    cls.addstmt(cxx.StmtDecl(meth))
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('private'))
        cls.addstmt(cxx.Typedef(cxx.Type('IPC::Message'),
                                cxx.Type('Message')))
        cls.addstmt(cxx.Typedef(cxx.Type(channelname),
                                cxx.Type('Channel')))
        cls.addstmt(cxx.Typedef(cxx.Type(channellistener),
                                cxx.Type('ChannelListener')))
        cls.addstmt(cxx.Whitespace.NL)
        
        # TODO manager param to constructor, when protocol is managed

        cls.addstmt(cxx.Label('public'))
        ctor = cxx.ConstructorDefn(cxx.ConstructorDecl(self.clsname))
        if p.decl.type.isToplevel():
            ctor.memberinits = [
                cxx.ExprMemberInit(
                    cxx.ExprVar('mChannel'),
                    [ cxx.ExprCall(
                            cxx.ExprVar('ALLOW_THIS_IN_INITIALIZER_LIST'),
                            [ cxx.ExprVar('this') ]) ]) ]
        cls.addstmt(ctor)
        cls.addstmt(cxx.Whitespace.NL)

        dtor = cxx.DestructorDefn(
            cxx.DestructorDecl(self.clsname, virtual=True))
        cls.addstmt(dtor)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.isToplevel():
            # open
            openmeth = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Open',
                    params=[ cxx.Decl(cxx.Type('Channel::Transport', ptr=True),
                                      'aTransport'),
                             cxx.Decl(cxx.Type('MessageLoop', ptr=True),
                                      'aThread = 0') ],
                    ret=cxx.Type('bool')))
            atransportvar = cxx.ExprVar('aTransport')
            mchannelvar = cxx.ExprVar('mChannel')
            openmeth.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(
                        cxx.ExprSelect(mchannelvar, '.', 'Open'),
                        [ atransportvar, cxx.ExprVar('aThread') ])))
            cls.addstmt(openmeth)
            cls.addstmt(cxx.Whitespace.NL)

            # close
            closemeth = cxx.MethodDefn(cxx.MethodDecl('Close'))
            closemeth.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(
                        cxx.ExprSelect(mchannelvar, '.', 'Close'))))
            cls.addstmt(closemeth)
            cls.addstmt(cxx.Whitespace.NL)

        # incoming message dispatchers
        self.asyncswitch = cxx.StmtSwitch(
            cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'), '.', 'type'), [ ]))
        if p.decl.type.toplevel().talksSync():
            self.syncswitch = deepcopy(self.asyncswitch)
            if p.decl.type.toplevel().talksRpc():
                self.rpcswitch = deepcopy(self.syncswitch)

        # implement child iface and add handlers to message switches
        self.cls = cls
        self.p = p
        for md in p.messageDecls:
            self.visitMessageDecl(md)

        # add default cases
        default = cxx.StmtBlock()
        default.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgNotKnown')))
        
        self.asyncswitch.addcase(cxx.DefaultLabel(), default)
        if p.decl.type.toplevel().talksSync():
            self.syncswitch.addcase(cxx.DefaultLabel(), default)
            if p.decl.type.toplevel().talksRpc():
                self.rpcswitch.addcase(cxx.DefaultLabel(), default)

        asynchandler = cxx.MethodDefn(
            cxx.MethodDecl(
                'OnMessageReceived', virtual=True,
                params=[ cxx.Decl(cxx.Type('Message', const=1, ref=1),'msg') ],
                ret=cxx.Type('Result')))

        if p.decl.type.toplevel().talksSync():
            synchandler = deepcopy(asynchandler)
            synchandler.decl.params.append(cxx.Decl(
                    cxx.Type('Message', ref=1, ptr=1), 'reply'))

            if p.decl.type.toplevel().talksRpc():
                rpchandler = deepcopy(synchandler)
                rpchandler.decl.name = 'OnCallReceived'


        def addDispatcher(mdefn, dispatchMethod, params):
            mdefn.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), '__route')))
            routevar = cxx.ExprVar('__route')
            mdefn.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        routevar,
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'),
                                                    '.', 'routing_id')))))
            routeif = cxx.StmtIf(cxx.ExprBinary(
                    cxx.ExprVar('MSG_ROUTING_CONTROL'), '!=', routevar))
            routeif.ifb.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('ChannelListener', ptr=1), '__routed')))
            routedvar = cxx.ExprVar('__routed')
            routeif.ifb.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        routedvar,
                        cxx.ExprCall(cxx.ExprVar('Lookup'), [ routevar ]))))

            failif = cxx.StmtIf(cxx.ExprPrefixUnop(routedvar, '!'))
            failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgRouteError')))
            routeif.ifb.addstmt(failif)

            routeif.ifb.addstmt(cxx.StmtReturn(cxx.ExprCall(
                        cxx.ExprSelect(routedvar, '->', dispatchMethod),
                        params)))
            mdefn.addstmt(routeif)
            mdefn.addstmt(cxx.Whitespace.NL)

        dispatches = p.decl.type.isToplevel() and p.decl.type.isManager()

        if dispatches:
            addDispatcher(asynchandler, 'OnMessageReceived',
                          [ cxx.ExprVar('msg') ])
        # bug 509581: don't generate the switch stmt if there is only the 
        # default case; MSVC doesn't like that
        reterror = cxx.StmtReturn(cxx.ExprVar('MsgNotKnown'))

        if self.asyncswitch.nr_cases > 1:
            asynchandler.addstmt(self.asyncswitch)
        else:
            asynchandler.addstmt(reterror)
        cls.addstmt(asynchandler)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.toplevel().talksSync():
            if dispatches:
                addDispatcher(synchandler, 'OnMessageReceived',
                              [ cxx.ExprVar('msg'), cxx.ExprVar('reply') ])
            if self.syncswitch.nr_cases > 1:
                synchandler.addstmt(self.syncswitch)
            else:
                synchandler.addstmt(reterror)
            cls.addstmt(synchandler)
            cls.addstmt(cxx.Whitespace.NL)

            if p.decl.type.toplevel().talksRpc():
                if dispatches:
                    addDispatcher(rpchandler, 'OnCallReceived',
                                  [ cxx.ExprVar('msg'), cxx.ExprVar('reply') ])
                if self.rpcswitch.nr_cases > 1:
                    rpchandler.addstmt(self.rpcswitch)
                else:
                    rpchandler.addstmt(reterror)
                cls.addstmt(rpchandler)
                cls.addstmt(cxx.Whitespace.NL)

        # implement IProtocolManager interface
        if p.decl.type.isManager():
            register = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Register',
                    [ cxx.Decl(cxx.Type('ChannelListener', ptr=1), 'aRouted') ],
                    ret=cxx.Type('int32'),
                    virtual=1))
            registerid = cxx.MethodDefn(
                cxx.MethodDecl(
                    'RegisterID',
                    [ cxx.Decl(cxx.Type('ChannelListener', ptr=1), 'aRouted'),
                      cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('int32'),
                    virtual=1))
            lookup = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Lookup',
                    [ cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('ChannelListener', ptr=1),
                    virtual=1))
            unregister = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Unregister',
                    [ cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('void'),
                    virtual=1))

            idvar = cxx.ExprVar('aId')
            if p.decl.type.isToplevel():
                register.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'tmp')))
                tmpvar = cxx.ExprVar('tmp')
                register.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(tmpvar,
                                     p._cxx.nextRouteId)))
                register.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(
                            cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                           '.', 'AddWithID'),
                            [ cxx.ExprVar('aRouted'), tmpvar ])))
                register.addstmt(cxx.StmtReturn(tmpvar))

                registerid.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(
                            cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                           '.', 'AddWithID'),
                            [ cxx.ExprVar('aRouted'), idvar ])))
                registerid.addstmt(cxx.StmtReturn(idvar))

                lookup.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                    '.', 'Lookup'),
                                     [ cxx.ExprVar('aId') ])))
                unregister.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                    '.', 'Remove'),
                                     [ cxx.ExprVar('aId') ])))
            else:
                register.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Register'),
                                     [ cxx.ExprVar('aRouted') ])))
                registerid.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'RegisterID'),
                                     [ cxx.ExprVar('aRouted'), 
                                       cxx.ExprVar('aId') ])))
                lookup.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Lookup'),
                                     [ cxx.ExprVar('aId') ])))
                unregister.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Unregister'),
                                     [ cxx.ExprVar('aId') ])))
            cls.addstmt(register)
            cls.addstmt(registerid)
            cls.addstmt(lookup)
            cls.addstmt(unregister)
            cls.addstmt(cxx.Whitespace.NL)

        # private members and methods
        cls.addstmt(cxx.Label('private'))
        channeltype = cxx.Type('Channel')
        if p.decl.type.isManaged():
            channeltype.ptr = True # subprotocols inherit this
        cls.addstmt(cxx.StmtDecl(cxx.Decl(channeltype, 'mChannel')))
        if p.decl.type.isToplevel() and p.decl.type.isManager():
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('IDMap<ChannelListener>'), 'mActorMap')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('int'), p._cxx.routeidvar.name)))
        elif p.decl.type.isManaged():
            cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'mId')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'mPeerId')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type(p._cxx.managertype, ptr=1), 'mManager')))
        self.ns.addstmt(cls)
        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)

        # generate skeleton implementation of abstract actor class
        self.file.addthing(cxx.CppDirective('if', '0'))

        genskeleton = GenerateSkeletonImpl()
        genskeleton.fromclass(cls)
        [ self.file.addthing(thing) for thing in genskeleton.stuff ]

        self.file.addthing(cxx.CppDirective('endif', '// if 0'))


    def visitMessageDecl(self, md):
        def injectLogger(block, msgptr, note):
            block.addstmt(cxx.Whitespace.NL)
            block.addstmt(cxx.CppDirective('ifdef', 'DEBUG'))
            logif = cxx.StmtIf(cxx.ExprCall(
                    cxx.ExprVar('PR_GetEnv'),
                    [ cxx.ExprLiteral.String("MOZ_IPC_MESSAGE_LOG") ]))
            logif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                        cxx.ExprSelect(msgptr, '->', 'Log'),
                        [ cxx.ExprLiteral.String(
                                '['+ self.clsname +'] '+ note),
                          cxx.ExprVar('stderr') ])))
            block.addstmt(logif)
            block.addstmt(cxx.CppDirective('endif', '// ifdef DEBUG'))
            block.addstmt(cxx.Whitespace.NL)


        if self.sendsMessage(md):
            pfx = None
            if md.decl.type.isRpc():
                pfx = 'Call'
            else:
                pfx = 'Send'

            mdecl = deepcopy(md._cxx.method)
            mdecl.name = pfx + mdecl.name
            mdecl.virtual = False
            if md.decl.type.hasImplicitActorParam():
                objtype = cxx.Type(
                    (_protocolHeaderName(md.decl.type.constructedType().name())
                     + self.myside),
                    ptr=1)
            if md.decl.type.isCtor():
                mdecl.ret = objtype
            elif md.decl.type.isDtor():
                mdecl.params.insert(0, cxx.Decl(objtype, '__a'))
                objvar = cxx.ExprVar('__a')
            impl = cxx.MethodDefn(mdecl)

            if md.decl.type.isCtor():
                impl.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))
                objvar = cxx.ExprVar('__a')

                okcode = objvar
                failerrcode = cxx.ExprLiteral.ZERO
                valueerrcode = cxx.ExprLiteral.ZERO

                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            objvar,
                            cxx.ExprCall(cxx.ExprVar(md._cxx.method.name),
                                         [ cxx.ExprVar(p.name) for
                                           p in md._cxx.method.params ]))))
                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprLiteral.ZERO))
                impl.addstmt(failif)

                objid = cxx.ExprSelect(objvar, '->', 'mId')
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid,
                                     cxx.ExprCall(cxx.ExprVar('Register'),
                                                  [ objvar ]))))

                impl.addstmt(cxx.StmtDecl(
                        cxx.Decl(cxx.Type('mozilla::ipc::ActorHandle'),
                                 '__ah')))
                ahvar = cxx.ExprVar('__ah')
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(ahvar, '.', 'mId'), objid)))

                impl.addstmt(cxx.Whitespace.NL)

            elif md.decl.type.isDtor():
                okcode = cxx.ExprVar('NS_OK')
                failerrcode = cxx.ExprVar('NS_ERROR_FAILURE')
                valueerrcode = cxx.ExprVar('NS_ERROR_ILLEGAL_VALUE')

                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)

                # verify that this object indeed exists
                objid = cxx.ExprSelect(objvar, '->', 'mId')

                impl.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__b')))
                bvar = cxx.ExprVar('__b')
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            bvar,
                            cxx.ExprCast(
                                cxx.ExprCall(cxx.ExprVar('Lookup'), [ objid ]),
                                objtype, static=1))))
                failif = cxx.StmtIf(cxx.ExprBinary(objvar, '!=', bvar))
                failif.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)
                impl.addstmt(cxx.Whitespace.NL)

                impl.addstmt(cxx.StmtDecl(cxx.Decl(
                            cxx.Type('mozilla::ipc::ActorHandle'), '__ah')))
                ahvar = cxx.ExprVar('__ah')
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(cxx.ExprSelect(ahvar, '.', 'mId'),
                                     objid)))
                impl.addstmt(cxx.Whitespace.NL)

            else:               # normal message
                okcode = cxx.ExprVar('NS_OK')
                failerrcode = cxx.ExprVar('NS_ERROR_FAILURE')
                valueerrcode = cxx.ExprVar('NS_ERROR_ILLEGAL_VALUE')

            hasreply = md.decl.type.hasReply()
            if hasreply:
                impl.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('Message'),
                                                   '__reply')))
                replyvar = cxx.ExprVar('__reply')
            impl.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type(md._cxx.nsid, ptr=1),
                                               '__msg')))
            msgvar = cxx.ExprVar('__msg')

            msgctor = cxx.ExprNew(cxx.Type(md._cxx.nsid),
                                  [ cxx.ExprVar(p.name)
                                    for p in md._cxx.params ])
            if md.decl.type.hasImplicitActorParam():
                msgctor.args.append(ahvar)
                
            if self.p.decl.type.isManaged():
                route = cxx.ExprVar('mId')
            else:
                route = cxx.ExprVar('MSG_ROUTING_CONTROL')

            impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(msgvar, msgctor)))
            impl.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_routing_id'),
                                 [ route ])))

            if md.decl.type.isAsync():
                sendmethod = 'Send'
            elif md.decl.type.isSync():
                sendmethod = 'Send'
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_sync'),
                                     [ ])))
            elif md.decl.type.isRpc():
                sendmethod = 'Call'
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_rpc'),
                                     [ ])))
            else:
                assert 0

            # log the message, if DEBUG and the env var is set
            injectLogger(impl, msgvar, sendmethod +' ')
                
            sendcall = cxx.ExprCall(
                cxx.ExprSelect(
                    cxx.ExprVar('mChannel'), self.channelsel, sendmethod),
                [ msgvar ])
            if hasreply:
                sendcall.args.append(cxx.ExprAddrOf(replyvar))

            failif = cxx.StmtIf(cxx.ExprPrefixUnop(sendcall, '!'))
            failif.ifb.addstmt(cxx.StmtReturn(failerrcode))
            impl.addstmt(failif)

            if hasreply:
                unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsreplyid +'::Read'),
                                      [ cxx.ExprAddrOf(replyvar) ]
                                      + [ cxx.ExprVar(r.name)
                                          for r in md._cxx.returns ])
                if md.decl.type.hasImplicitActorParam():
                    unpack.args.append(cxx.ExprAddrOf(ahvar))
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(errhandle)

                # log the reply, maybe
                injectLogger(impl,
                             cxx.ExprCast(cxx.ExprAddrOf(replyvar),
                                          cxx.Type(md._cxx.nsreplyid, ptr=1),
                                          static=1),
                             'got reply ')

            if md.decl.type.isCtor():
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprVar('this'))))
                if self.p.decl.type.isManaged():
                    channelvar = cxx.ExprVar('mChannel')
                else:
                    channelvar = cxx.ExprAddrOf(cxx.ExprVar('mChannel'))
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mChannel'),
                            channelvar)))

            elif md.decl.type.isDtor():
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprVar('Unregister'), [ objid ])))
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid, cxx.ExprLiteral.ZERO)))
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprLiteral.ZERO)))

                calldtor = cxx.ExprCall(
                    cxx.ExprVar(md._cxx.method.name),
                    ([ objvar ]
                     + [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                     + [ cxx.ExprVar(r.name) for r in md._cxx.returns ]))
                failif = cxx.StmtIf(cxx.ExprCall(
                        cxx.ExprVar('NS_FAILED'), [ calldtor ]))
                failif.addifstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)

            impl.addstmt(cxx.StmtReturn(okcode))
            self.cls.addstmt(impl)
            self.cls.addstmt(cxx.Whitespace.NL)


        # create case for this message in the big handler switch statement
        if self.receivesMessage(md):
            if md.decl.type.isRpc():  pfx = 'Answer'
            else:                     pfx = 'Recv'

            case = cxx.CaseLabel(md._cxx.nsid +'__ID')
            block = cxx.StmtBlock()
            hasactor = md.decl.type.hasImplicitActorParam()
            if hasactor:
                objtype = cxx.Type(
                    (_protocolHeaderName(md.decl.type.constructedType().name())
                     + self.myside),
                    ptr=1)
                objvar = cxx.ExprVar('__a')
                objid = cxx.ExprSelect(objvar, '->', 'mId')

            for param in md._cxx.params:
                block.addstmt(cxx.StmtDecl(param))
            for ret in md._cxx.returns:
                block.addstmt(cxx.StmtDecl(ret))
            if hasactor:
                block.addstmt(cxx.StmtDecl(cxx.Decl(
                            cxx.Type('mozilla::ipc::ActorHandle'), '__ah')))
                ahvar = cxx.ExprVar('__ah')
            block.addstmt(cxx.Whitespace.NL)

            msgvar = cxx.ExprVar('msg')
            unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsid +'::Read'),
                                  [ cxx.ExprAddrOf(msgvar) ]
                                  + [ cxx.ExprAddrOf(cxx.ExprVar(p.name))
                                      for p in md._cxx.params ])
            if hasactor:
                unpack.args.append(cxx.ExprAddrOf(ahvar))
            errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
            errhandle.ifb.addstmt(cxx.StmtReturn(
                    cxx.ExprVar('MsgPayloadError')))
            block.addstmt(errhandle)

            injectLogger(block, 
                         cxx.ExprCast(cxx.ExprAddrOf(msgvar),
                                      cxx.Type(md._cxx.nsid, ptr=1, const=1),
                                      static=1),
                         pfx +' ')

            if md.decl.type.isCtor():
                block.addstmt(cxx.Whitespace.NL)
                block.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))

                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            objvar,
                            cxx.ExprCall(
                                cxx.ExprVar(md._cxx.method.name),
                                ([ cxx.ExprVar(p.name) for
                                   p in md._cxx.params ]
                                 + [ cxx.ExprAddrOf(cxx.ExprVar(r.name)) for
                                     r in md._cxx.returns ])))))
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(errhandle)

            elif md.decl.type.isDtor():
                block.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))

                routevar = cxx.ExprSelect(ahvar, '.', 'mId')
                dcast = cxx.ExprCast(
                    cxx.ExprCall(cxx.ExprVar('Lookup'), [ routevar ]),
                    objtype,
                    static=1)
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(objvar, dcast)))

                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(failif)

            # call the C++ handler hook for messages other than ctors
            if not md.decl.type.isCtor():
                callimpl = cxx.ExprCall(
                    cxx.ExprVar(pfx + md.decl.progname), [ ])
                if md.decl.type.isDtor():
                    callimpl.args += [ objvar ]
                callimpl.args += [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                callimpl.args += [ cxx.ExprAddrOf(cxx.ExprVar(r.name))
                                   for r in md._cxx.returns ]
                errhandle = cxx.StmtIf(cxx.ExprCall(
                        cxx.ExprVar('NS_FAILED'), [ callimpl ]))
                errhandle.ifb.addstmt(cxx.StmtReturn(
                        cxx.ExprVar('MsgValueError')))
                block.addstmt(errhandle)

            block.addstmt(cxx.Whitespace.NL)

            if md.decl.type.isCtor():
                othersideid = cxx.ExprSelect(ahvar, '.', 'mId')
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid,
                                     cxx.ExprCall(cxx.ExprVar('RegisterID'),
                                                  [ objvar, othersideid ]))))
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprVar('this'))))
                if self.p.decl.type.isToplevel():
                    channelvar = cxx.ExprAddrOf(cxx.ExprVar('mChannel'))
                else:
                    channelvar = cxx.ExprVar('mChannel')
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mChannel'),
                            channelvar)))
                block.addstmt(cxx.Whitespace.NL)
            elif md.decl.type.isDtor():
                calldtor = cxx.ExprCall(
                    cxx.ExprVar(md._cxx.method.name),
                    ([ objvar ]
                     + [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                     + [ cxx.ExprAddrOf(cxx.ExprVar(r.name)) for
                         r in md._cxx.returns ]))
                failif = cxx.StmtIf(cxx.ExprCall(
                        cxx.ExprVar('NS_FAILED'), [ calldtor ]))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(failif)
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprVar('Unregister'), [ routevar ])))
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(routevar, cxx.ExprLiteral.ZERO)))

            if md.decl.type.hasReply():
                if not md.decl.type.hasReply():
                    block.addstmt(cxx.StmtDecl(
                            cxx.Decl(cxx.Type('Message', ptr=1), 'reply')))
                replyvar = cxx.ExprVar('reply')
                replymsgctor = cxx.ExprNew(
                    cxx.Type(md._cxx.nsreplyid),
                    [ cxx.ExprVar(r.name) for r in md._cxx.returns ])
                if md.decl.type.hasImplicitActorParam():
                    replymsgctor.args.append(ahvar)
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(replyvar,
                                                        replymsgctor)))
                block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_reply'),
                            [ ])))

                if md.decl.type.isSync():
                    block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_sync'),
                            [ ])))
                elif md.decl.type.isRpc():
                    block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_rpc'),
                            [ ])))
                else:
                    assert 0

                injectLogger(block,
                             cxx.ExprCast(replyvar,
                                          cxx.Type(md._cxx.nsreplyid, ptr=1),
                                          static=1),
                             'replying with ')

                if md.decl.type.isAsync(): # => isCtor or isDtor
                    # when this is sync or rpc, we return the reply
                    # message to the dispatcher.  when it's async, 
                    # we have to explicitly send it back
                    if self.p.decl.type.isManaged():
                        sel = '->'
                    else:
                        sel = '.'
                    failif = cxx.StmtIf(cxx.ExprPrefixUnop(
                            cxx.ExprCall(
                                cxx.ExprSelect(cxx.ExprVar('mChannel'), sel, 'Send'),
                                [ replyvar ]),
                            '!'))
                    failif.addifstmt(
                        cxx.StmtReturn(cxx.ExprVar('MsgValueError')))

                    block.addstmt(failif)

            block.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgProcessed')))

            if md.decl.type.isAsync():
                self.asyncswitch.addcase(case, block)
            elif md.decl.type.isSync():
                self.syncswitch.addcase(case, block)
            else:
                self.rpcswitch.addcase(case, block)


class GenerateProtocolParentHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'Parent', 'Child')

    def sendsMessage(self, md):
        return not md.decl.type.isIn()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isIn()

class GenerateProtocolChildHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'Child', 'Parent')

    def sendsMessage(self, md):
        return not md.decl.type.isOut()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isOut()


class GenerateSkeletonImpl(cxx.Visitor):
    def __init__(self, name='ActorImpl'):
        self.name = name
        self.stuff = [ ]
        self.cls = None
        self.methodimpls = [ ]

    def fromclass(self, cls):
        cls.accept(self)
        self.stuff.append(cxx.Whitespace('''
//-----------------------------------------------------------------------------
// Skeleton implementation of abstract actor class

'''))
        self.stuff.append(cxx.Whitespace('// Header file contents\n'))
        self.stuff.append(self.cls)

        self.stuff.append(cxx.Whitespace.NL)
        self.stuff.append(cxx.Whitespace('\n// C++ file contents\n'))
        self.stuff.extend(self.methodimpls)

    def visitClass(self, cls):
        self.cls = cxx.Class(self.name, inherits=[ cxx.Inherit(cls.name) ])
        cxx.Visitor.visitClass(self, cls)

    def visitMethodDecl(self, md):
        if not md.pure:
            return
        decl = deepcopy(md)
        decl.pure = 0
        impl = cxx.MethodDefn(cxx.MethodDecl(self.implname(md.name),
                                             params=md.params,
                                             ret=md.ret))
        if md.ret.ptr:
            impl.addstmt(cxx.StmtReturn(cxx.ExprLiteral.ZERO))
        else:
            impl.addstmt(cxx.StmtReturn(cxx.ExprVar('NS_ERROR_NOT_IMPLEMENTED')))

        self.cls.addstmt(cxx.StmtDecl(decl))
        self.addmethodimpl(impl)

    def visitConstructorDecl(self, cd):
        self.cls.addstmt(cxx.StmtDecl(cxx.ConstructorDecl(self.name)))
        self.addmethodimpl(
            cxx.ConstructorDefn(cxx.ConstructorDecl(self.implname(self.name))))
        
    def visitDestructorDecl(self, dd):
        self.cls.addstmt(
            cxx.StmtDecl(cxx.DestructorDecl(self.name, virtual=1)))
        # FIXME/cjones: hack!
        self.addmethodimpl(
            cxx.DestructorDefn(cxx.ConstructorDecl(self.implname('~' +self.name))))

    def addmethodimpl(self, impl):
        self.methodimpls.append(impl)
        self.methodimpls.append(cxx.Whitespace.NL)

    def implname(self, method):
        return self.name +'::'+ method

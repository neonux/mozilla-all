# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is mozilla.org code.
#
# Contributor(s):
#   Chris Jones <jones.chris.g@gmail.com>
#
# Alternatively, the contents of this file may be used under the terms of
# either of the GNU General Public License Version 2 or later (the "GPL"),
# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

import os
from copy import deepcopy

from ipdl.ast import Visitor, ASYNC, SYNC, RPC, IN, OUT, INOUT
import ipdl.cxx.ast as cxx


def _joinProtocolNamespacesName(sep, p, pname):
    return sep.join([ ns.namespace for ns in p.namespaces ] + [ pname ])

def _protocolIncludeGuard(p, pname):
    return _joinProtocolNamespacesName('_', p, pname) +'_h'

def _protocolHeaderFilename(p, pname):
    return _joinProtocolNamespacesName('/', p, pname)+ '.h'

def _protocolHeaderName(pname):
    return pname +'Protocol'


class _struct: pass

class LowerToCxx:
    def lower(self, tu):
        '''returns a list of cxx.File representing the lowered form of |tu|'''
        pname = _protocolHeaderName(tu.protocol.name)
        pheader = cxx.File(pname +'.h')
        gph = GenerateProtocolHeader()
        gph.lower(tu, pname, pheader)

        parentname = pname +'Parent'
        parentheader = cxx.File(parentname +'.h')
        GenerateProtocolParentHeader().lower(
            tu, pname, parentname, parentheader, gph.typedefs)

        childname = pname +'Child'
        childheader = cxx.File(childname +'.h')
        GenerateProtocolChildHeader().lower(
            tu, pname, childname, childheader, gph.typedefs)

        return pheader, parentheader, childheader


##-----------------------------------------------------------------------------
class GenerateProtocolHeader(Visitor):
    '''creates a "generic" protocol header from an IPDL AST'''
    def __init__(self):
        self.pname = None
        self.file = None
        self.ns = None          # the namespace we toss all this stuff into
        # list of typedefs for the protocol namespace.  these are 
        # produced from various places in the AST and collected here
        self.typedefs = [ ]

    def lower(self, tu, protocol, outcxxfile):
        self.pname = protocol
        self.file = outcxxfile
        tu.accept(self)


    def typedef(self, t, name):
        self.typedefs.append(cxx.Typedef(cxx.Type(t), cxx.Type(name)))

    def injectTypedefs(self, scope):
        for tdef in self.typedefs:
            scope.addstmt(tdef)


    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        Visitor.visitTranslationUnit(self, tu)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))


    def visitCxxInclude(self, inc):
        self.file.addthing(cxx.CppDirective('include', '"'+ inc.file +'"'))


    def visitProtocolInclude(self, inc):
        p = inc.tu.protocol
        self.file.addthing(
            cxx.CppDirective(
                'include',
                '"'+ _protocolHeaderFilename(p, _protocolHeaderName(p.name)) +'"'))
        # FIXME/cjones: not clear what types we need from other header
#         if p.decl.fullname is not None:
#             self.typedef(p.decl.fullname, p.decl.shortname)


    def visitUsingStmt(self, using):
        if using.decl.fullname is not None:
            self.typedef(using.decl.fullname, using.decl.shortname)


    def visitProtocol(self, p):
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        ns = cxx.Namespace(self.pname)
        self.ns.addstmt(ns)
        self.ns = ns
        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)

        # previsit the messages and stash away some common info used
        # several times later
        for md in p.messageDecls:
            md.accept(self)

        # TODO
        for ts in p.transitionStmts:
            ts.accept(self)
        ns.addstmt(cxx.StmtDecl(cxx.Decl(cxx.TypeEnum('State'), '')))
        ns.addstmt(cxx.Whitespace.NL)

        # spit out message type enum and classes
        msgstart = self.pname +'MsgStart << 12'
        msgenum = cxx.TypeEnum(self.pname +'MsgType')
        msgenum.addId(self.pname +'Start', msgstart)
        msgenum.addId(self.pname +'PreStart', '('+ msgstart +') - 1')

        for md in p.messageDecls:
            msgenum.addId(md._cxx.id +'__ID')
            if md.decl.type.hasReply():
                msgenum.addId(md._cxx.replyid +'__ID')            

        msgenum.addId(self.pname +'End')
        ns.addstmt(cxx.StmtDecl(cxx.Decl(msgenum, '')))

        for md in p.messageDecls:
            ns.addstmt(generateMessageClass(md, self.injectTypedefs))
            if md.decl.type.hasReply():
                ns.addstmt(generateReplyClass(md, self.injectTypedefs))

        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)


    def visitMessageDecl(self, md):
        # where we squirrel away some common information
        setattr(md, '_cxx', _struct())

        md._cxx.params = [ ]
        for param in md.inParams:
            md._cxx.params.append(cxx.Decl(cxx.Type(param.type.name()),
                                           param.progname))
        md._cxx.returns = [ ]
        for param in md.outParams:
            md._cxx.returns.append(cxx.Decl(cxx.Type(param.type.name()),
                                            param.progname))

        # generate C++ interface to message sending/handling
        method = cxx.MethodDecl(
            name=md.decl.progname,
            params=[ ],
            ret=cxx.Type('nsresult'),
            virtual=True)
        for param in md._cxx.params:
            pcopy = deepcopy(param)
            pcopy.type.const = True
            pcopy.type.ref = True
            method.params.append(pcopy)
        for ret in md._cxx.returns:
            rcopy = deepcopy(ret)
            rcopy.type.ptr = True
            method.params.append(rcopy)
        md._cxx.method = method

        # the ID is used by the IPC layer only
        md._cxx.id = 'Msg_%s'% (md.decl.progname)
        md._cxx.nsid = '%s::%s'% (self.pname, md._cxx.id)
        if md.decl.type.hasReply():
            md._cxx.replyid = 'Reply_%s'% (md.decl.progname)
            md._cxx.nsreplyid = '%s::%s'% (self.pname, md._cxx.replyid)


def generateMsgClass(md, clsname, params, typedefInjector):
        cls = cxx.Class(name=clsname,
                        inherits=[ cxx.Inherit('IPC::Message') ])
        cls.addstmt(cxx.Label('private'))
        typedefInjector(cls)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('public'))

        idenum = cxx.TypeEnum()
        idenum.addId('ID', clsname +'__ID')
        cls.addstmt(cxx.StmtDecl(cxx.Decl(idenum, '')))

        # FIXME/cjones: need to handle "managed" messages

        constparams = deepcopy(params)
        writestmts = [ ]
        for cparam in constparams:
            cparam.type.const = True
            cparam.type.ref = True

        if md.decl.type.hasImplicitActorParam():
            constparams.append(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle', const=1, ref=1),
                    '__ah'))

        # make the message constructor (serializer)
        ctordecl = cxx.ConstructorDecl(clsname, params=constparams)

        superinit = cxx.ExprMemberInit(
            cxx.ExprVar('IPC::Message'),
            [ cxx.ExprVar('MSG_ROUTING_NONE'),
              cxx.ExprVar('ID'),
              cxx.ExprVar('PRIORITY_NORMAL') ])

        ctor = cxx.ConstructorDefn(ctordecl, [ superinit ])
        for cparam in constparams:
            ctor.addstmt(
                cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar('IPC::WriteParam'),
                                          [ cxx.ExprVar('this'),
                                            cxx.ExprVar(cparam.name) ])))
        cls.addstmt(ctor)

        cls.addstmt(cxx.Whitespace.NL)

        # make the message deserializer
        outparams = deepcopy(params)
        for oparam in outparams:
            oparam.type.ptr = True

        if md.decl.type.hasImplicitActorParam():
            outparams.append(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle', ptr=1),
                    '__ah'))

        reader = cxx.MethodDefn(
            cxx.MethodDecl(
                'Read',
                params=([ cxx.Decl(cxx.Type('Message', ptr=True, const=True),
                                   'msg') ]
                        + outparams),
                ret=cxx.Type('bool'),
                static=True))

        # avoid generating an unused variable when we don't deserialize
        # anything.  why generate the method anyway?  it keeps other code
        # consistent, and we might do some checking in here eventually
        if len(outparams):
            # hack
            reader.addstmt(
                cxx.StmtDecl(cxx.Decl(cxx.Type('void', ptr=True), 'iter = 0')))
            reader.addstmt(cxx.Whitespace.NL)

        for oparam in outparams:
            cond = cxx.ExprPrefixUnop(
                cxx.ExprCall(cxx.ExprVar('IPC::ReadParam'),
                             [ cxx.ExprVar('msg'),
                               cxx.ExprAddrOf(cxx.ExprVar('iter')),
                               cxx.ExprVar(oparam.name) ]),
                '!')
            ifstmt = cxx.StmtIf(cond)
            # false isn't a var
            ifstmt.addifstmt(cxx.StmtReturn(cxx.ExprVar('false')))
            reader.addstmt(ifstmt)
            reader.addstmt(cxx.Whitespace.NL)

        # false isn't a var
        reader.addstmt(cxx.StmtReturn(cxx.ExprVar('true')))

        cls.addstmt(reader)

        return cls

def generateMessageClass(md, typedefInjector):
    return generateMsgClass(md, md._cxx.id, md._cxx.params, typedefInjector)

def generateReplyClass(md, typedefInjector):
    return generateMsgClass(md, md._cxx.replyid, md._cxx.returns, typedefInjector)


##-----------------------------------------------------------------------------
_channelTable = {
    'Async': [ 'mozilla', 'ipc', 'AsyncChannel' ],
    'Sync': [ 'mozilla', 'ipc', 'SyncChannel' ],
    'Rpc': [ 'mozilla', 'ipc', 'RPCChannel' ]
}


class GenerateProtocolActorHeader(Visitor):
    def __init__(self, myside, otherside):
        self.myside = myside  # "Parent" or "Child"
        self.otherside = otherside
        self.clsname = None
        self.pname = None
        self.file = None
        self.ns = None
        self.typedefs = None

    def lower(self, tu, pname, clsname, cxxHeaderFile, typedefs):
        self.pname = pname
        self.clsname = clsname
        self.file = cxxHeaderFile
        self.typedefs = typedefs
        tu.accept(self)

    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.clsname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        mainheader = _protocolHeaderFilename(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('include', '"'+ mainheader +'"'))

        self.protocol = tu.protocol

        for pinc in tu.protocolIncludes:
            pinc.accept(self)

        tu.protocol.accept(self)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))

    def visitProtocolInclude(self, pi):
        p = pi.tu.protocol
        if self.protocol.decl.type.isManagerOf(p.decl.type):
            header = _protocolHeaderFilename(
                p, _protocolHeaderName(p.name)+ self.myside)
            self.file.addthing(cxx.CppDirective('include', '"'+ header +'"'))


    def visitProtocol(self, p):
        if p.decl.type.isManager():
            self.file.addthing(cxx.CppDirective('include', '"base/id_map.h"'))

        channel = _channelTable[p.decl.type.sendSemantics.pretty]
        channelname = '::'.join(channel)
        channelfile = '/'.join(channel) +'.h'
        if p.decl.type.isToplevel():
            self.channelsel = '.'
        else:
            self.channelsel = '->'

        self.file.addthing(cxx.CppDirective('include', '"'+ channelfile +'"'))
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)

        inherits = [ cxx.Inherit(channelname +'::Listener') ]
        if p.decl.type.isManager():
            inherits.append(cxx.Inherit('mozilla::ipc::IProtocolManager'))
        cls = cxx.Class(self.clsname, inherits=inherits, abstract=True)

        if p.decl.type.isManaged():
            cls.addstmt(cxx.FriendClassDecl(
                    _protocolHeaderName(p.decl.type.manager.name())
                                        + self.myside))
            cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('protected'))
        for typedef in self.typedefs:
            cls.addstmt(typedef)
        cls.addstmt(cxx.Whitespace.NL)

        # constructor/destructor interface for subclass to impl
        for md in p.messageDecls:
            if md.decl.type.isCtor() or md.decl.type.isDtor():
                objtype = cxx.Type(
                    (_protocolHeaderName(md.decl.type.constructedType().name())
                     + self.myside),
                    ptr=1)
                meth = deepcopy(md._cxx.method)
                meth.pure = True
                if md.decl.type.isCtor():
                    meth.ret = objtype
                else:
                    meth.params.insert(0, cxx.Decl(objtype, '__a'))
                cls.addstmt(cxx.StmtDecl(meth))

            elif self.receivesMessage(md):
                if md.decl.type.isRpc():  pfx = 'Answer'
                else:                     pfx = 'Recv'
                meth = deepcopy(md._cxx.method);
                meth.pure = True
                meth.name = pfx + meth.name
                cls.addstmt(cxx.StmtDecl(meth))
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('private'))
        cls.addstmt(cxx.Typedef(cxx.Type('IPC::Message'),
                                cxx.Type('Message')))
        cls.addstmt(cxx.Typedef(cxx.Type(channelname),
                                cxx.Type('Channel')))
        cls.addstmt(cxx.Whitespace.NL)
        
        # TODO manager param to constructor, when protocol is managed

        cls.addstmt(cxx.Label('public'))
        ctor = cxx.ConstructorDefn(cxx.ConstructorDecl(self.clsname))
        if p.decl.type.isToplevel():
            ctor.memberinits = [
                cxx.ExprMemberInit(cxx.ExprVar('mChannel'),
                                   [ cxx.ExprVar('this') ]) ]
        cls.addstmt(ctor)
        cls.addstmt(cxx.Whitespace.NL)

        dtor = cxx.DestructorDefn(
            cxx.DestructorDecl(self.clsname, virtual=True))
        cls.addstmt(dtor)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.isToplevel():
            # open
            openmeth = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Open',
                    params=[ cxx.Decl(cxx.Type('IPC::Channel', ptr=True),
                                      'aChannel'),
                             cxx.Decl(cxx.Type('MessageLoop', ptr=True),
                                      'aThread = 0') ],
                    ret=cxx.Type('bool')))
            openmeth.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(
                        cxx.ExprSelect(cxx.ExprVar('mChannel'), '.', 'Open'),
                        [ cxx.ExprVar('aChannel'), cxx.ExprVar('aThread') ])))
            cls.addstmt(openmeth)
            cls.addstmt(cxx.Whitespace.NL)

            # close
            closemeth = cxx.MethodDefn(cxx.MethodDecl('Close'))
            closemeth.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(
                        cxx.ExprSelect(cxx.ExprVar('mChannel'), '.', 'Close'))))
            cls.addstmt(closemeth)
            cls.addstmt(cxx.Whitespace.NL)

        # incoming message dispatchers
        self.asyncswitch = cxx.StmtSwitch(
            cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'), '.', 'type'), [ ]))
        if p.decl.type.talksSync():
            self.syncswitch = deepcopy(self.asyncswitch)
            if p.decl.type.talksRpc():
                self.rpcswitch = deepcopy(self.syncswitch)

        # implement child iface and add handlers to message switches
        self.cls = cls
        self.p = p
        for md in p.messageDecls:
            self.visitMessageDecl(md)

        # add default cases
        default = cxx.StmtBlock()
        default.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgNotKnown')))
        
        self.asyncswitch.addcase(cxx.DefaultLabel(), default)
        if p.decl.type.talksSync():
            self.syncswitch.addcase(cxx.DefaultLabel(), default)
            if p.decl.type.talksRpc():
                self.rpcswitch.addcase(cxx.DefaultLabel(), default)

        asynchandler = cxx.MethodDefn(
            cxx.MethodDecl(
                'OnMessageReceived', virtual=True,
                params=[ cxx.Decl(cxx.Type('Message', const=1, ref=1),'msg') ],
                ret=cxx.Type('Result')))

        if p.decl.type.talksSync():
            synchandler = deepcopy(asynchandler)
            synchandler.decl.params.append(cxx.Decl(
                    cxx.Type('Message', ref=1, ptr=1), 'reply'))

            if p.decl.type.talksRpc():
                rpchandler = deepcopy(synchandler)
                rpchandler.decl.name = 'OnCallReceived'


        def addDispatcher(mdefn, dispatchMethod, params):
            mdefn.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), '__route')))
            routevar = cxx.ExprVar('__route')
            mdefn.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        routevar,
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'),
                                                    '.', 'routing_id')))))
            routeif = cxx.StmtIf(cxx.ExprBinary(
                    cxx.ExprVar('MSG_ROUTING_CONTROL'), '!=', routevar))
            routeif.ifb.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('Channel::Listener', ptr=1), '__routed')))
            routedvar = cxx.ExprVar('__routed')
            routeif.ifb.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        routedvar,
                        cxx.ExprCall(cxx.ExprVar('Lookup'), [ routevar ]))))

            failif = cxx.StmtIf(cxx.ExprPrefixUnop(routedvar, '!'))
            failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgRouteError')))
            routeif.ifb.addstmt(failif)

            routeif.ifb.addstmt(cxx.StmtReturn(cxx.ExprCall(
                        cxx.ExprSelect(routedvar, '->', dispatchMethod),
                        params)))
            mdefn.addstmt(routeif)
            mdefn.addstmt(cxx.Whitespace.NL)

        dispatches = p.decl.type.isToplevel() and p.decl.type.isManager()

        # FIXME/cjones: re-enable when we have AsyncChannel
        if 0 and dispatches:
            addDispatcher(asynchandler, 'OnMessageReceived',
                          [ cxx.ExprVar('msg') ])
        asynchandler.addstmt(self.asyncswitch)
        cls.addstmt(asynchandler)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.talksSync():
            # FIXME/cjones: re-enable when we have SyncChannel
            if 0 and dispatches:
                addDispatcher(synchandler, 'OnMessageReceived',
                              [ cxx.ExprVar('msg'), cxx.ExprVar('reply') ])
            synchandler.addstmt(self.syncswitch)
            cls.addstmt(synchandler)
            cls.addstmt(cxx.Whitespace.NL)

            if p.decl.type.talksRpc():
                if dispatches:
                    addDispatcher(rpchandler, 'OnCallReceived',
                                  [ cxx.ExprVar('msg'), cxx.ExprVar('reply') ])
                rpchandler.addstmt(self.rpcswitch)
                cls.addstmt(rpchandler)
                cls.addstmt(cxx.Whitespace.NL)

        # implement IProtocolManager interface
        if p.decl.type.isManager():
            register = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Register',
                    [ cxx.Decl(cxx.Type('Channel::Listener', ptr=1), 'aRouted') ],
                    ret=cxx.Type('int32'),
                    virtual=1))
            lookup = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Lookup',
                    [ cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('Channel::Listener', ptr=1),
                    virtual=1))
            unregister = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Unregister',
                    [ cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('void'),
                    virtual=1))

            if p.decl.type.isToplevel():
                register.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                    '.', 'Add'),
                                     [ cxx.ExprVar('aRouted') ])))
                lookup.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                    '.', 'Lookup'),
                                     [ cxx.ExprVar('aId') ])))
                unregister.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                    '.', 'Remove'),
                                     [ cxx.ExprVar('aId') ])))
            else:
                register.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Register'),
                                     [ cxx.ExprVar('aRouted') ])))
                lookup.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Lookup'),
                                     [ cxx.ExprVar('aId') ])))
                unregister.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Unregister'),
                                     [ cxx.ExprVar('aId') ])))
            cls.addstmt(register)
            cls.addstmt(lookup)
            cls.addstmt(unregister)
            cls.addstmt(cxx.Whitespace.NL)

        # private members and methods
        cls.addstmt(cxx.Label('private'))
        channeltype = cxx.Type('Channel')
        if p.decl.type.isManaged():
            channeltype.ptr = True # subprotocols inherit this
        cls.addstmt(cxx.StmtDecl(cxx.Decl(channeltype, 'mChannel')))
        if p.decl.type.isToplevel() and p.decl.type.isManager():
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('IDMap<Channel::Listener>'), 'mActorMap')))
        else:
            cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'mId')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'mPeerId')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('mozilla::ipc::IProtocolManager', ptr=1),
                        'mManager')))
        self.ns.addstmt(cls)
        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)


    def visitMessageDecl(self, md):
        # TODO special handling of constructor messages

        # create method for "that" interface
        if self.sendsMessage(md):
            pfx = None
            if md.decl.type.isRpc():
                pfx = 'Call'
            else:
                pfx = 'Send'

            mdecl = deepcopy(md._cxx.method)
            mdecl.name = pfx + mdecl.name
            mdecl.virtual = False
            if md.decl.type.hasImplicitActorParam():
                objtype = cxx.Type(
                    (_protocolHeaderName(md.decl.type.constructedType().name())
                     + self.myside),
                    ptr=1)
            if md.decl.type.isCtor():
                mdecl.ret = objtype
            elif md.decl.type.isDtor():
                mdecl.params.insert(0, cxx.Decl(objtype, '__a'))
                objvar = cxx.ExprVar('__a')
            impl = cxx.MethodDefn(mdecl)

            if md.decl.type.isCtor():
                impl.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))
                objvar = cxx.ExprVar('__a')

                okcode = objvar
                failerrcode = cxx.ExprLiteral.ZERO
                valueerrcode = cxx.ExprLiteral.ZERO

                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            objvar,
                            cxx.ExprCall(cxx.ExprVar(md._cxx.method.name),
                                         [ cxx.ExprVar(p.name) for
                                           p in md._cxx.method.params ]))))
                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprLiteral.ZERO))
                impl.addstmt(failif)

                objid = cxx.ExprSelect(objvar, '->', 'mId')
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid,
                                     cxx.ExprCall(cxx.ExprVar('Register'),
                                                  [ objvar ]))))

                impl.addstmt(cxx.StmtDecl(
                        cxx.Decl(cxx.Type('mozilla::ipc::ActorHandle'),
                                 '__ah')))
                ahvar = cxx.ExprVar('__ah')
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(ahvar, '.', 'm'+ self.myside +'Id'),
                            objid)))

                impl.addstmt(cxx.Whitespace.NL)

            elif md.decl.type.isDtor():
                okcode = cxx.ExprVar('NS_OK')
                failerrcode = cxx.ExprVar('NS_ERROR_FAILURE')
                valueerrcode = cxx.ExprVar('NS_ERROR_ILLEGAL_VALUE')

                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)

                # verify that this object indeed exists
                objid = cxx.ExprSelect(objvar, '->', 'mId')

                impl.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__b')))
                bvar = cxx.ExprVar('__b')
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            bvar,
                            cxx.ExprCast(
                                cxx.ExprCall(cxx.ExprVar('Lookup'), [ objid ]),
                                objtype, static=1))))
                failif = cxx.StmtIf(cxx.ExprBinary(objvar, '!=', bvar))
                failif.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)
                impl.addstmt(cxx.Whitespace.NL)

                impl.addstmt(cxx.StmtDecl(cxx.Decl(
                            cxx.Type('mozilla::ipc::ActorHandle'), '__ah')))
                ahvar = cxx.ExprVar('__ah')
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(
                            cxx.ExprSelect(ahvar,
                                           '.', 'm'+ self.myside +'Id'),
                            objid)))
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(
                            cxx.ExprSelect(ahvar,
                                           '.', 'm'+ self.otherside +'Id'),
                            cxx.ExprSelect(objvar,
                                           '->', 'mPeerId'))))
                impl.addstmt(cxx.Whitespace.NL)

            else:               # normal message
                okcode = cxx.ExprVar('NS_OK')
                failerrcode = cxx.ExprVar('NS_ERROR_FAILURE')
                valueerrcode = cxx.ExprVar('NS_ERROR_ILLEGAL_VALUE')

            hasreply = md.decl.type.hasReply()
            if hasreply:
                impl.addstmt(cxx.StmtDecl(
                        cxx.Decl(cxx.Type('Message'), '__reply')))
                replyvar = cxx.ExprVar('__reply')
            impl.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('Message', ptr=1),
                                               '__msg')))
            msgvar = cxx.ExprVar('__msg')

            msgctor = cxx.ExprNew(cxx.Type(md._cxx.nsid),
                                  [ cxx.ExprVar(p.name)
                                    for p in md._cxx.params ])
            if md.decl.type.hasImplicitActorParam():
                msgctor.args.append(ahvar)
                
            if self.p.decl.type.isManaged():
                route = cxx.ExprVar('mPeerId')
            else:
                route = cxx.ExprVar('MSG_ROUTING_CONTROL')

            impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(msgvar, msgctor)))
            impl.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_routing_id'),
                                 [ route ])))

            sendcall = cxx.ExprCall(
                cxx.ExprSelect(
                    cxx.ExprVar('mChannel'), self.channelsel, 'Call'),
                [ msgvar ])
            if hasreply:
                sendcall.args.append(cxx.ExprAddrOf(replyvar))

            failif = cxx.StmtIf(cxx.ExprPrefixUnop(sendcall, '!'))
            failif.ifb.addstmt(cxx.StmtReturn(failerrcode))
            impl.addstmt(failif)

            if hasreply:
                unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsreplyid +'::Read'),
                                      [ cxx.ExprAddrOf(replyvar) ]
                                      + [ cxx.ExprVar(r.name)
                                          for r in md._cxx.returns ])
                if md.decl.type.hasImplicitActorParam():
                    unpack.args.append(cxx.ExprAddrOf(ahvar))
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(errhandle)

                # FIXME/cjones: assuming we have sync/rpc constructors, need
                # code for async ones if that makes sense
                if md.decl.type.isCtor():
                    impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                                cxx.ExprSelect(objvar, '->', 'mPeerId'),
                                cxx.ExprSelect(ahvar, '.',
                                               'm'+ self.otherside +'Id'))))
                    impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                                cxx.ExprSelect(objvar, '->', 'mManager'),
                                cxx.ExprVar('this'))))
                    if self.p.decl.type.isManaged():
                        channelvar = cxx.ExprVar('mChannel')
                    else:
                        channelvar = cxx.ExprAddrOf(cxx.ExprVar('mChannel'))
                    impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                                cxx.ExprSelect(objvar, '->', 'mChannel'),
                                channelvar)))

                elif md.decl.type.isDtor():
                    impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprVar('Unregister'), [ objid ])))
                    impl.addstmt(cxx.StmtExpr(
                            cxx.ExprAssn(objid, cxx.ExprLiteral(-1, 'd'))))
                    impl.addstmt(cxx.StmtExpr(
                            cxx.ExprAssn(
                                cxx.ExprSelect(objvar, '->', 'mManager'),
                                cxx.ExprLiteral.ZERO)))
                    impl.addstmt(cxx.StmtExpr(
                            cxx.ExprAssn(
                                cxx.ExprSelect(objvar, '->', 'mPeerId'),
                                cxx.ExprLiteral(-1, 'd'))))

            impl.addstmt(cxx.StmtReturn(okcode))
            self.cls.addstmt(impl)
            self.cls.addstmt(cxx.Whitespace.NL)


        # create case for this message in the big handler switch statement
        if self.receivesMessage(md):
            if md.decl.type.isRpc():  pfx = 'Answer'
            else:                     pfx = 'Recv'

            case = cxx.CaseLabel(md._cxx.nsid +'__ID')
            block = cxx.StmtBlock()
            hasactor = md.decl.type.hasImplicitActorParam()
            if hasactor:
                objtype = cxx.Type(
                    (_protocolHeaderName(md.decl.type.constructedType().name())
                     + self.myside),
                    ptr=1)
                objvar = cxx.ExprVar('__a')
                objid = cxx.ExprSelect(objvar, '->', 'mId')

            for param in md._cxx.params:
                block.addstmt(cxx.StmtDecl(param))
            for ret in md._cxx.returns:
                block.addstmt(cxx.StmtDecl(ret))
            if hasactor:
                block.addstmt(cxx.StmtDecl(cxx.Decl(
                            cxx.Type('mozilla::ipc::ActorHandle'), '__ah')))
                ahvar = cxx.ExprVar('__ah')
            block.addstmt(cxx.Whitespace.NL)

            unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsid +'::Read'),
                                  [ cxx.ExprAddrOf(cxx.ExprVar('msg')) ]
                                  + [ cxx.ExprAddrOf(cxx.ExprVar(p.name))
                                      for p in md._cxx.params ])
            if hasactor:
                unpack.args.append(cxx.ExprAddrOf(ahvar))
            errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
            errhandle.ifb.addstmt(cxx.StmtReturn(
                    cxx.ExprVar('MsgPayloadError')))
            block.addstmt(errhandle)

            if md.decl.type.isCtor():
                block.addstmt(cxx.Whitespace.NL)
                block.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))

                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            objvar,
                            cxx.ExprCall(
                                cxx.ExprVar(md._cxx.method.name),
                                ([ cxx.ExprVar(p.name) for
                                   p in md._cxx.params ]
                                 + [ cxx.ExprAddrOf(cxx.ExprVar(r.name)) for
                                     r in md._cxx.returns ])))))
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(errhandle)

            elif md.decl.type.isDtor():
                block.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))

                routevar = cxx.ExprSelect(ahvar, '.', 'm'+ self.myside +'Id')
                dcast = cxx.ExprCast(
                    cxx.ExprCall(cxx.ExprVar('Lookup'), [ routevar ]),
                    objtype,
                    static=1)
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(objvar, dcast)))

                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(failif)

                failif = cxx.StmtIf(cxx.ExprCall(
                        cxx.ExprVar(md._cxx.method.name),
                        ([ objvar ]
                         + [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                         + [ cxx.ExprAddrOf(cxx.ExprVar(r.name)) for
                             r in md._cxx.returns ])))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(failif)
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprVar('Unregister'), [ routevar ])))
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(routevar, cxx.ExprLiteral(-1, 'd'))))

            else:
                callimpl = cxx.ExprCall(
                    cxx.ExprVar(pfx + md.decl.progname), [ ])
                callimpl.args += [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                callimpl.args += [ cxx.ExprAddrOf(cxx.ExprVar(r.name))
                               for r in md._cxx.returns ]
                errhandle = cxx.StmtIf(callimpl)
                errhandle.ifb.addstmt(cxx.StmtReturn(
                        cxx.ExprVar('MsgValueError')))
                block.addstmt(errhandle)

            block.addstmt(cxx.Whitespace.NL)

            if md.decl.type.isCtor():
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(ahvar, '.',
                                           'm'+ self.myside +'Id'),
                            cxx.ExprAssn(objid,
                                         cxx.ExprCall(cxx.ExprVar('Register'),
                                                      [ objvar ])))))
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mPeerId'),
                            cxx.ExprSelect(ahvar, '.',
                                           'm'+ self.otherside +'Id'))))
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprVar('this'))))
                if self.p.decl.type.isToplevel():
                    channelvar = cxx.ExprAddrOf(cxx.ExprVar('mChannel'))
                else:
                    channelvar = cxx.ExprVar('mChannel')
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mChannel'),
                            channelvar)))
                block.addstmt(cxx.Whitespace.NL)

            if md.decl.type.hasReply():
                replyvar = cxx.ExprVar('reply')
                replymsgctor = cxx.ExprNew(
                    cxx.Type(md._cxx.nsreplyid),
                    [ cxx.ExprVar(r.name) for r in md._cxx.returns ])
                if md.decl.type.hasImplicitActorParam():
                    replymsgctor.args.append(ahvar)
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(replyvar,
                                                        replymsgctor)))
                block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_reply'),
                            [ ])))

            block.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgProcessed')))

            if md.decl.type.isAsync():
                self.asyncswitch.addcase(case, block)
            elif md.decl.type.isSync():
                self.syncswitch.addcase(case, block)
            else:
                self.rpcswitch.addcase(case, block)


class GenerateProtocolParentHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'Parent', 'Child')

    def sendsMessage(self, md):
        return not md.decl.type.isIn()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isIn()

class GenerateProtocolChildHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'Child', 'Parent')

    def sendsMessage(self, md):
        return not md.decl.type.isOut()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isOut()

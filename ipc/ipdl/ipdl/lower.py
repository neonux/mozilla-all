# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is mozilla.org code.
#
# Contributor(s):
#   Chris Jones <jones.chris.g@gmail.com>
#
# Alternatively, the contents of this file may be used under the terms of
# either of the GNU General Public License Version 2 or later (the "GPL"),
# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

import os
from copy import deepcopy

from ipdl.ast import Visitor, ASYNC, SYNC, RPC, IN, OUT, INOUT
import ipdl.cxx.ast as cxx


def _joinProtocolNamespacesName(sep, p, pname):
    return sep.join([ ns.namespace for ns in p.namespaces ] + [ pname ])

def _protocolIncludeGuard(p, pname):
    return _joinProtocolNamespacesName('_', p, pname) +'_h'

def _protocolHeaderFilename(p, pname):
    return _joinProtocolNamespacesName(os.path.sep, p, pname)+ '.h'

def _protocolHeaderName(pname):
    return pname +'Protocol'


class _struct: pass

class LowerToCxx:
    def lower(self, tu):
        '''returns a list of cxx.File representing the lowered form of |tu|'''
        pname = _protocolHeaderName(tu.protocol.name)
        pheader = cxx.File(pname +'.h')
        GenerateProtocolHeader().lower(tu, pname, pheader)

        parentname = pname +'Parent'
        parentheader = cxx.File(parentname +'.h')
        GenerateProtocolParentHeader().lower(
            tu, pname, parentname, parentheader)

        childname = pname +'Child'
        childheader = cxx.File(childname +'.h')
        GenerateProtocolChildHeader().lower(
            tu, pname, childname, childheader)

        return pheader, parentheader, childheader


##-----------------------------------------------------------------------------
class GenerateProtocolHeader(Visitor):
    '''creates a "generic" protocol header from an IPDL AST'''
    def __init__(self):
        self.pname = None
        self.file = None
        self.ns = None          # the namespace we toss all this stuff into
        # list of typedefs for the protocol namespace.  these are 
        # produced from various places in the AST and collected here
        self.typedefs = [ ]

    def lower(self, tu, protocol, outcxxfile):
        self.pname = protocol
        self.file = outcxxfile
        tu.accept(self)


    def typedef(self, t, name):
        self.typedefs.append(cxx.Typedef(cxx.Type(t), cxx.Type(name)))

    def injectTypedefs(self, scope):
        for tdef in self.typedefs:
            scope.addstmt(tdef)


    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        Visitor.visitTranslationUnit(self, tu)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))


    def visitCxxInclude(self, inc):
        self.file.addthing(cxx.CppDirective('include', '"'+ inc.file +'"'))


    def visitProtocolInclude(self, inc):
        p = inc.tu.protocol
        self.file.addthing(
            cxx.CppDirective(
                'include',
                '"'+ _protocolHeaderFilename(p, _protocolHeaderName(p.name)) +'"'))
        # FIXME/cjones: not clear what types we need from other header
#         if p.decl.fullname is not None:
#             self.typedef(p.decl.fullname, p.decl.shortname)


    def visitUsingStmt(self, using):
        if using.decl.fullname is not None:
            self.typedef(using.decl.fullname, using.decl.shortname)


    def visitProtocol(self, p):
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        ns = cxx.Namespace(self.pname)
        self.ns.addstmt(ns)
        self.ns = ns
        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)

        # previsit the messages and stash away some common info used
        # several times later
        for md in p.messageDecls:
            md.accept(self)

        # generate parent and child interfaces
        iparent = cxx.Class('IParent', interface=True)
        iparent.addstmt(cxx.Label('protected'))
        self.injectTypedefs(iparent)
        iparent.addstmt(cxx.Whitespace.NL)

        p.accept(GenerateParentInterface(iparent))
        ns.addstmt(iparent)
        ns.addstmt(cxx.Whitespace.NL)

        ns.addstmt(cxx.Whitespace.NL)
        ichild = cxx.Class('IChild', interface=True)
        ichild.addstmt(cxx.Label('protected'))
        self.injectTypedefs(ichild)
        ichild.addstmt(cxx.Whitespace.NL)

        p.accept(GenerateChildInterface(ichild))
        ns.addstmt(ichild)
        ns.addstmt(cxx.Whitespace.NL)

        # TODO
        for ts in p.transitionStmts:
            ts.accept(self)
        ns.addstmt(cxx.StmtDecl(cxx.Decl(cxx.TypeEnum('State'), '')))
        ns.addstmt(cxx.Whitespace.NL)

        # spit out message type enum and classes
        msgstart = self.pname +'MsgStart << 12'
        msgenum = cxx.TypeEnum(self.pname +'MsgType')
        msgenum.addId(self.pname +'Start', msgstart)
        msgenum.addId(self.pname +'PreStart', '('+ msgstart +') - 1')

        for md in p.messageDecls:
            msgenum.addId(md._cxx.id +'__ID')
            if md.decl.type.hasReply():
                msgenum.addId(md._cxx.replyid +'__ID')            

        msgenum.addId(self.pname +'End')
        ns.addstmt(cxx.StmtDecl(cxx.Decl(msgenum, '')))

        for md in p.messageDecls:
            ns.addstmt(generateMessageClass(md, self.injectTypedefs))
            if md.decl.type.hasReply():
                ns.addstmt(generateReplyClass(md, self.injectTypedefs))

        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)


    def visitMessageDecl(self, md):
        # where we squirrel away some common information
        setattr(md, '_cxx', _struct())

        md._cxx.params = [ ]
        for param in md.inParams:
            md._cxx.params.append(cxx.Decl(cxx.Type(param.type.name()),
                                           param.progname))
        md._cxx.returns = [ ]
        for param in md.outParams:
            md._cxx.returns.append(cxx.Decl(cxx.Type(param.type.name()),
                                            param.progname))

        # generate C++ interface to message sending/handling
        method = cxx.MethodDecl(
            name=md.decl.progname,
            params=[ ],
            ret=cxx.Type('nsresult'),
            virtual=True)
        for param in md._cxx.params:
            pcopy = deepcopy(param)
            pcopy.type.const = True
            pcopy.type.ref = True
            method.params.append(pcopy)
        for ret in md._cxx.returns:
            rcopy = deepcopy(ret)
            rcopy.type.ptr = True
            method.params.append(rcopy)
        md._cxx.method = method

        # the ID is used by the IPC layer only
        md._cxx.id = 'Msg_%s'% (md.decl.progname)
        md._cxx.nsid = '%s::%s'% (self.pname, md._cxx.id)
        if md.decl.type.hasReply():
            md._cxx.replyid = 'Reply_%s'% (md.decl.progname)
            md._cxx.nsreplyid = '%s::%s'% (self.pname, md._cxx.replyid)


class GenerateInterface(Visitor):
    def __init__(self, iface, name):
        self.iface = iface
        self.name = name

    def visitProtocol(self, p):
        ifc = self.iface
        n = self.name

        ifc.addstmt(cxx.Label('public'))
        nmsgs = len(p.messageDecls)
        for i, msgdecl in enumerate(p.messageDecls):
            msgdecl.accept(self)

        ifc.addstmt(cxx.Whitespace.NL)
        ifc.addstmt(cxx.Label('protected'))
        ifc.addstmt(cxx.ConstructorDefn(
                cxx.ConstructorDecl(n)))
        ifc.addstmt(cxx.DestructorDefn(
                cxx.DestructorDecl(n, virtual=True)))

        # disable unwanted ctors/operators
        ifc.addstmt(cxx.Whitespace.NL)
        ifc.addstmt(cxx.Label('private'))
        ref = cxx.Type(n, ref=True)
        constref = cxx.Type(n, const=True, ref=True)
        ifc.addstmt(cxx.StmtDecl(
                cxx.ConstructorDecl(n,
                                    params=[ cxx.Decl(constref, '')])))
        ifc.addstmt(cxx.StmtDecl(
                cxx.MethodDecl('operator=',
                               params= [ cxx.Decl(constref, '') ],
                               ret=ref)))

    def visitMessageDecl(self, md):
        if self.msgComesIn(md.decl.type):
            method = deepcopy(md._cxx.method)
            method.pure = True
            self.iface.addstmt(cxx.StmtDecl(method))
            self.iface.addstmt(cxx.Whitespace.NL)


class GenerateParentInterface(GenerateInterface):
    def __init__(self, iparent):
        GenerateInterface.__init__(self, iparent, iparent.name)
    def msgComesIn(self, mtype):  return mtype.isIn() or mtype.isInout()

class GenerateChildInterface(GenerateInterface):
    def __init__(self, iparent):
        GenerateInterface.__init__(self, iparent, iparent.name)
    def msgComesIn(self, mtype):  return mtype.isOut() or mtype.isInout()


def generateMsgClass(clsname, params, typedefInjector):
        cls = cxx.Class(name=clsname,
                        inherits=[ cxx.Inherit('IPC::Message') ])
        cls.addstmt(cxx.Label('private'))
        typedefInjector(cls)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label('public'))

        idenum = cxx.TypeEnum()
        idenum.addId('ID', clsname +'__ID')
        cls.addstmt(cxx.StmtDecl(cxx.Decl(idenum, '')))

        # FIXME/cjones: need to handle "managed" messages

        constparams = deepcopy(params)
        writestmts = [ ]
        for cparam in constparams:
            cparam.type.const = True
            cparam.type.ref = True
            writestmts.append(
                cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar('IPC::WriteParam'),
                                          [ cxx.ExprVar('this'),
                                            cxx.ExprVar(cparam.name) ])))

        # make the message constructor (serializer)
        ctordecl = cxx.ConstructorDecl(clsname, params=constparams)

        superinit = cxx.ExprMemberInit(
            cxx.ExprVar('IPC::Message'),
            [ cxx.ExprVar('MSG_ROUTING_CONTROL'),
              cxx.ExprVar('ID'),
              cxx.ExprVar('PRIORITY_NORMAL') ])

        ctor = cxx.ConstructorDefn(ctordecl, [ superinit ])
        for writestmt in writestmts:
            ctor.addstmt(writestmt)
        cls.addstmt(ctor)

        cls.addstmt(cxx.Whitespace.NL)

        # make the message deserializer
        outparams = deepcopy(params)
        for oparam in outparams:
            oparam.type.ptr = True

        reader = cxx.MethodDefn(
            cxx.MethodDecl(
                'Read',
                params=([ cxx.Decl(cxx.Type('Message', ptr=True, const=True),
                                   'msg') ]
                        + outparams),
                ret=cxx.Type('bool'),
                static=True))

        # avoid generating an unused variable when we don't deserialize
        # anything.  why generate the method anyway?  it keeps other code
        # consistent, and we might do some checking in here eventually
        if len(outparams):
            # hack
            reader.addstmt(
                cxx.StmtDecl(cxx.Decl(cxx.Type('void', ptr=True), 'iter = 0')))
            reader.addstmt(cxx.Whitespace.NL)

        for oparam in outparams:
            cond = cxx.ExprPrefixUnop(
                cxx.ExprCall(cxx.ExprVar('IPC::ReadParam'),
                             [ cxx.ExprVar('msg'),
                               cxx.ExprAddrOf(cxx.ExprVar('iter')),
                               cxx.ExprVar(oparam.name) ]),
                '!')
            ifstmt = cxx.StmtIf(cond)
            # false isn't a var
            ifstmt.addifstmt(cxx.StmtReturn(cxx.ExprVar('false')))
            reader.addstmt(ifstmt)
            reader.addstmt(cxx.Whitespace.NL)

        # false isn't a var
        reader.addstmt(cxx.StmtReturn(cxx.ExprVar('true')))

        cls.addstmt(reader)

        return cls

def generateMessageClass(md, typedefInjector):
    return generateMsgClass(md._cxx.id, md._cxx.params, typedefInjector)

def generateReplyClass(md, typedefInjector):
    return generateMsgClass(md._cxx.replyid, md._cxx.returns, typedefInjector)


##-----------------------------------------------------------------------------
_channelTable = {
    'Async': [ 'mozilla', 'ipc', 'AsyncChannel' ],
    'Sync': [ 'mozilla', 'ipc', 'SyncChannel' ],
    'Rpc': [ 'mozilla', 'ipc', 'RPCChannel' ]
}


class GenerateProtocolActorHeader(Visitor):
    def __init__(self, thisiface, thatiface):
        self.thisiface = thisiface
        self.thatiface = thatiface
        self.clsname = None
        self.pname = None
        self.file = None
        self.ns = None

    def lower(self, tu, pname, clsname, cxxHeaderFile):
        self.pname = pname
        self.clsname = clsname
        self.file = cxxHeaderFile
        tu.accept(self)

    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.clsname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        mainheader = _protocolHeaderFilename(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('include', '"'+ mainheader +'"'))

        tu.protocol.accept(self)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))


    def visitProtocol(self, p):
        channel = _channelTable[p.decl.type.sendSemantics.pretty]
        channelname = '::'.join(channel)
        channelfile = '/'.join(channel) +'.h'
        if p.decl.type.isToplevel():
            self.channelsel = '.'
        else:
            self.channelsel = '->'

        self.file.addthing(cxx.CppDirective('include', '"'+ channelfile +'"'))
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)

        iface = p.decl.fullname +'Protocol::'+ self.thatiface
        cls = cxx.Class(self.clsname,
                        inherits=[ cxx.Inherit(iface),
                                   cxx.Inherit(channelname +'::Listener') ],
                        final=True)

        cls.addstmt(cxx.Label('private'))
        impliface = p.decl.fullname +'Protocol::'+ self.thisiface
        cls.addstmt(cxx.Typedef(cxx.Type('IPC::Message'),
                                cxx.Type('Message')))
        cls.addstmt(cxx.Typedef(cxx.Type(channelname),
                                cxx.Type('Channel')))
        cls.addstmt(cxx.Typedef(cxx.Type(impliface),
                                cxx.Type(self.thisiface)))
        cls.addstmt(cxx.Whitespace.NL)
        
        # TODO manager param to constructor, when protocol is managed

        cls.addstmt(cxx.Label('public'))
        ctor = cxx.ConstructorDefn(
            cxx.ConstructorDecl(
                self.clsname,
                [ cxx.Decl(cxx.Type(self.thisiface, ptr=True), 'aImpl') ]),
            [ cxx.ExprMemberInit(cxx.ExprVar('mImpl'),
                                 [ cxx.ExprVar('aImpl') ]) ])
        if p.decl.type.isToplevel():
            ctor.memberinits.append(
                cxx.ExprMemberInit(cxx.ExprVar('mChannel'),
                                   [ cxx.ExprVar('this') ]))
        cls.addstmt(ctor)
        cls.addstmt(cxx.Whitespace.NL)

        dtor = cxx.DestructorDefn(
            cxx.DestructorDecl(self.clsname, virtual=True))
        cls.addstmt(dtor)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.isToplevel():
            # open
            openmeth = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Open',
                    params=[ cxx.Decl(cxx.Type('IPC::Channel', ptr=True),
                                      'aChannel'),
                             cxx.Decl(cxx.Type('MessageLoop', ptr=True),
                                      'aThread = 0') ],
                    ret=cxx.Type('bool')))
            openmeth.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(
                        cxx.ExprSelect(cxx.ExprVar('mChannel'), '.', 'Open'),
                        [ cxx.ExprVar('aChannel'), cxx.ExprVar('aThread') ])))
            cls.addstmt(openmeth)
            cls.addstmt(cxx.Whitespace.NL)

            # close
            closemeth = cxx.MethodDefn(cxx.MethodDecl('Close'))
            closemeth.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(
                        cxx.ExprSelect(cxx.ExprVar('mChannel'), '.', 'Close'))))
            cls.addstmt(closemeth)
            cls.addstmt(cxx.Whitespace.NL)

        # incoming message dispatchers
        self.asyncswitch = cxx.StmtSwitch(
            cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'), '.', 'type'), [ ]))
        if p.decl.type.talksSync():
            self.syncswitch = deepcopy(self.asyncswitch)
            if p.decl.type.talksRpc():
                self.rpcswitch = deepcopy(self.syncswitch)

        # implement child iface and add handlers to message switches
        self.cls = cls
        for md in p.messageDecls:
            self.visitMessageDecl(md)

        # add default cases
        default = cxx.StmtBlock()
        default.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgNotKnown')))
        
        self.asyncswitch.addcase(cxx.DefaultLabel(), default)
        if p.decl.type.talksSync():
            self.syncswitch.addcase(cxx.DefaultLabel(), default)
            if p.decl.type.talksRpc():
                self.rpcswitch.addcase(cxx.DefaultLabel(), default)

        asynchandler = cxx.MethodDefn(
            cxx.MethodDecl(
                'OnMessageReceived', virtual=True,
                params=[ cxx.Decl(cxx.Type('Message', const=1, ref=1),'msg') ],
                ret=cxx.Type('Result')))

        if p.decl.type.talksSync():
            synchandler = deepcopy(asynchandler)
            synchandler.decl.params.append(cxx.Decl(
                    cxx.Type('Message', ref=1, ptr=1), 'reply'))

            if p.decl.type.talksRpc():
                rpchandler = deepcopy(synchandler)
                rpchandler.decl.name = 'OnCallReceived'

        asynchandler.addstmt(self.asyncswitch)
        cls.addstmt(asynchandler)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.talksSync():
            synchandler.addstmt(self.syncswitch)
            cls.addstmt(synchandler)
            cls.addstmt(cxx.Whitespace.NL)

            if p.decl.type.talksRpc():
                rpchandler.addstmt(self.rpcswitch)
                cls.addstmt(rpchandler)
                cls.addstmt(cxx.Whitespace.NL)

        # private members and methods

        # TODO handle manager stuff: lookups, routing

        cls.addstmt(cxx.Label('private'))
        cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type(self.thisiface, ptr=True),
                                          'mImpl')))
        channeltype = cxx.Type('Channel')
        if p.decl.type.isManaged():
            channeltype.ptr = True # subprotocols inherit this
        cls.addstmt(cxx.StmtDecl(cxx.Decl(channeltype, 'mChannel')))

        self.ns.addstmt(cls)
        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)


    def visitMessageDecl(self, md):
        # TODO special handling of constructor messages

        # create method for "that" interface
        if self.sendsMessage(md):
            impl = cxx.MethodDefn(md._cxx.method)

            impl.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('nsresult'), '__rv')))
            rv = cxx.ExprVar('__rv')
            failif = cxx.StmtIf(rv)
            failif.ifb.addstmt(cxx.StmtReturn(rv))

            hasreply = md.decl.type.hasReply()
            if hasreply:
                impl.addstmt(cxx.StmtDecl(
                        cxx.Decl(cxx.Type('Message'), 'reply')))
                reply = cxx.ExprVar('reply')
            impl.addstmt(cxx.Whitespace.NL)

            sendcall = cxx.ExprCall(
                cxx.ExprSelect(
                    cxx.ExprVar('mChannel'), self.channelsel, 'Call'),
                [ cxx.ExprNew(cxx.Type(md._cxx.nsid),
                              [ cxx.ExprVar(p.name)
                                for p in md._cxx.params ]) ])
            if hasreply:
                sendcall.args.append(cxx.ExprAddrOf(reply))

            # TODO special handling of actor handles

            impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(rv, sendcall)))
            if not hasreply:
                impl.addstmt(cxx.StmtReturn(rv))
                self.cls.addstmt(impl)
                self.cls.addstmt(cxx.Whitespace.NL)
            else:
                impl.addstmt(failif)

                unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsreplyid +'::Read'),
                                      [ cxx.ExprAddrOf(cxx.ExprVar('reply')) ]
                                      + [ cxx.ExprVar(r.name)
                                          for r in md._cxx.returns ])
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(
                        cxx.ExprVar('MsgPayloadError')))
                impl.addstmt(errhandle)

                # TODO special handling of actor handles

                impl.addstmt(cxx.StmtReturn(cxx.ExprVar('NS_OK')))

            self.cls.addstmt(impl)
            self.cls.addstmt(cxx.Whitespace.NL)


        # create case for this message in the big handler switch statement
        if self.receivesMessage(md):
            case = cxx.CaseLabel(md._cxx.nsid +'__ID')
            block = cxx.StmtBlock()

            rv = cxx.ExprVar('__rv')
            for param in md._cxx.params:
                block.addstmt(cxx.StmtDecl(param))
            for ret in md._cxx.returns:
                block.addstmt(cxx.StmtDecl(ret))
            block.addstmt(cxx.Whitespace.NL)

            unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsid +'::Read'),
                                  [ cxx.ExprAddrOf(cxx.ExprVar('msg')) ]
                                  + [ cxx.ExprAddrOf(cxx.ExprVar(p.name))
                                      for p in md._cxx.params ])
            errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
            errhandle.ifb.addstmt(cxx.StmtReturn(
                    cxx.ExprVar('MsgPayloadError')))
            block.addstmt(errhandle)

            # TODO special handling of actor handles

            callimpl = cxx.ExprCall(
                cxx.ExprSelect(cxx.ExprVar('mImpl'), '->',
                               md.decl.progname), [ ])
            callimpl.args += [ cxx.ExprVar(p.name) for p in md._cxx.params ]
            callimpl.args += [ cxx.ExprAddrOf(cxx.ExprVar(r.name))
                               for r in md._cxx.returns ]
            errhandle = cxx.StmtIf(callimpl)
            errhandle.ifb.addstmt(cxx.StmtReturn(
                    cxx.ExprVar('MsgValueError')))
            block.addstmt(errhandle)

            # TODO special handling of actor handles

            if md.decl.type.hasReply():
                replymsg = cxx.ExprNew(
                    cxx.Type(md._cxx.nsreplyid),
                    [ cxx.ExprVar(r.name) for r in md._cxx.returns ])
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(cxx.ExprVar('reply'),
                                                        replymsg)))

            block.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgProcessed')))

            if md.decl.type.isAsync():
                self.asyncswitch.addcase(case, block)
            elif md.decl.type.isSync():
                self.syncswitch.addcase(case, block)
            else:
                self.rpcswitch.addcase(case, block)


class GenerateProtocolParentHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'IParent', 'IChild')

    def sendsMessage(self, md):
        return not md.decl.type.isIn()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isIn()

class GenerateProtocolChildHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'IChild', 'IParent')

    def sendsMessage(self, md):
        return not md.decl.type.isOut()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isOut()

<?xml version="1.0"?>
<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
<?xml-stylesheet 
  href="chrome://mochikit/content/tests/SimpleTest/test.css"
  type="text/css"?>
<!--
https://bugzilla.mozilla.org/show_bug.cgi?id=558403
-->
<window title="Mozilla Bug 558406"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <title>Test for Bug 558403</title>
  <script type="application/javascript" 
          src="chrome://mochikit/content/MochiKit/packed.js"></script>
  <script type="application/javascript" 
          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
  <script type="application/javascript"
          src="chrome://mochikit/content/tests/SimpleTest/WindowSnapshot.js"></script>

  <body  xmlns="http://www.w3.org/1999/xhtml">
    <a target="_blank" 
       href="https://bugzilla.mozilla.org/show_bug.cgi?id=558403">
      Mozilla Bug 558403
    </a>

    <p id="display">
    </p>
    <div id="content" style="display: none">
    </div>
    <pre id="test">
    </pre>
  </body>

  <script type="application/javascript">
    <![CDATA[
      /* This code is mostly copied from chrome/test/unit/head_crtestutils.js */

      const NS_CHROME_MANIFESTS_FILE_LIST = "ChromeML";

      const Cc = Components.classes;
      const Ci = Components.interfaces;
      const Cr = Components.results;

      function ArrayEnumerator(array)
      {
        this.array = array;
      }

      ArrayEnumerator.prototype = {
        pos: 0,
        
        hasMoreElements: function() {
          return this.pos < this.array.length;
        },
        
        getNext: function() {
          if (this.pos < this.array.length)
            return this.array[this.pos++];
          throw Cr.NS_ERROR_FAILURE;
        },

        QueryInterface: function(iid) {
          if (iid.equals(Ci.nsISimpleEnumerator)
           || iid.equals(Ci.nsISupports))
            return this;

          throw Cr.NS_ERROR_NO_INTERFACE;
        }
      };

      function ChromeProvider(manifests)
      {
        this._manifests = manifests;
      }

      ChromeProvider.prototype = {
        getFile: function(prop, persistent) {
          throw Cr.NS_ERROR_FAILURE;
        },

        getFiles: function(prop) {
          if (prop == NS_CHROME_MANIFESTS_FILE_LIST) {
            return new ArrayEnumerator(this._manifests);
          }
          throw Cr.NS_ERROR_FAILURE;
        },

        QueryInterface: function(iid) {
          if (iid.equals(Ci.nsIDirectoryServiceProvider)
           || iid.equals(Ci.nsIDirectoryServiceProvider2)
           || iid.equals(Ci.nsISupports))
            return this;

          throw Cr.NS_ERROR_NO_INTERFACE;
        }
      };

      let dirSvc = Cc["@mozilla.org/file/directory_service;1"].
                   getService(Ci.nsIDirectoryService);
      function registerManifests(manifests)
      {
        let provider = new ChromeProvider(manifests);
        dirSvc.registerProvider(provider);
        return provider;
      }

      // This part is adapted from reftest.js to add support for reftest-wait to WindowSnapshot
      function shouldWait(contentRootElement)
      {
        // use getAttribute because className works differently in HTML and SVG
        return contentRootElement &&
               contentRootElement.hasAttribute('class') &&
               contentRootElement.getAttribute('class').split(/\s+/)
                                 .indexOf("reftest-wait") != -1;
      }

      function snapshotFrame(frame, state) {
        var stopAfterPaintReceived = false;
        var currentDoc = frame.contentDocument;
        var utils = frame.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
            .getInterface(Ci.nsIDOMWindowUtils);
        contentRootElement = frame.contentDocument.documentElement;

        function InitCurrentCanvasWithSnapshot()
        {
          var win = frame.contentWindow;
          el = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          el.width = win.innerWidth;
          el.height = win.innerHeight;

          // drawWindow requires privileges
          netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');

          var ctx = el.getContext("2d");
          ctx.drawWindow(win, win.scrollX, win.scrollY,
                         win.innerWidth, win.innerHeight,
                         "rgb(255,255,255)",
                         ctx.DRAWWINDOW_DRAW_CARET);
	  return el;
        }

        function DocumentLoaded()
        {
          if (state == 1) {
            s1 = InitCurrentCanvasWithSnapshot();
          } else if (state == 2) {
            s2 = InitCurrentCanvasWithSnapshot();
            [equal, str1, str2] = compareSnapshots(s1, s2, true);
            ok(equal, "logical and visual documents should be identical: expected " +
               str1 + " but got " + str2);
        
            // cleanup
            dirSvc.unregisterProvider(provider);
            cr.checkForNewChrome();
            prefs.clearUserPref(XUL_CACHE_PREF);
            SimpleTest.finish();
          }
        }

        function FlushRendering() {
            // Flush pending restyles and reflows
            contentRootElement.getBoundingClientRect();
            // Flush out invalidation
            utils.processUpdates();
        }

        function WhenMozAfterPaintFlushed(continuation) {
            if (utils.isMozAfterPaintPending) {
                function handler() {
                    frame.removeEventListener("MozAfterPaint", handler, false);
                    continuation();
                }
                frame.addEventListener("MozAfterPaint", handler, false);
            } else {
                continuation();
            }
        }

        function FinishWaitingForTestEnd() {
            setTimeout(DocumentLoaded, 0);
        }

        function AttrModifiedListener() {
            if (shouldWait())
                return;

            // We don't want to be notified again
            contentRootElement.removeEventListener("DOMAttrModified", AttrModifiedListener, false);
            // Wait for the next return-to-event-loop before continuing to flush rendering and
            // check isMozAfterPaintPending --- for example, the attribute may have been modified
            // in an subdocument's load event handler, in which case we need load event processing
            // to complete and unsuppress painting before we check isMozAfterPaintPending.
            setTimeout(AttrModifiedListenerContinuation, 0);
        }

        function AttrModifiedListenerContinuation() {
            FlushRendering();

            if (utils.isMozAfterPaintPending) {
                // Wait for the last invalidation to have happened and been snapshotted before
                // we stop the test
                stopAfterPaintReceived = true;
            } else {
                // Nothing to wait for, so stop now
                FinishWaitingForTestEnd();
            }
        }

        function StartWaitingForTestEnd() {
            FlushRendering();

            function continuation() {
                contentRootElement.addEventListener("DOMAttrModified", AttrModifiedListener, false); 

                if (!shouldWait()) {
                    // reftest-wait was already removed (during the interval between OnDocumentLoaded
                    // calling setTimeout(StartWaitingForTestEnd,0) below, and this function
                    // actually running), so let's fake a direct notification of the attribute
                    // change.
                    AttrModifiedListener();
                    return;
                }
            }
            WhenMozAfterPaintFlushed(continuation);
        }

        // After this load event has finished being dispatched, painting is normally
        // unsuppressed, which invalidates the entire window. So ensure
        // StartWaitingForTestEnd runs after that invalidation has been requested.
        setTimeout(StartWaitingForTestEnd, 0);
      }

    ]]>
  </script>

  <script class="testbody" type="application/javascript">
    <![CDATA[

      /** Test for Bug 558403 **/
      SimpleTest.waitForExplicitFinish();

      // Disable XUL cache temporarily
      let prefs = Cc["@mozilla.org/preferences-service;1"].
                  getService(Ci.nsIPrefBranch);
      const XUL_CACHE_PREF = "nglayout.debug.disable_xul_cache";
      prefs.setBoolPref(XUL_CACHE_PREF, true);

      // Register our manifest
      let cr = Cc["@mozilla.org/chrome/chrome-registry;1"].
               getService(Ci.nsIXULChromeRegistry);
      let manifests = [];
      let currentManifests = dirSvc.QueryInterface(Ci.nsIProperties)
                                   .get(NS_CHROME_MANIFESTS_FILE_LIST,
                                        Ci.nsISimpleEnumerator);
      while (currentManifests.hasMoreElements())
        manifests.push(currentManifests.getNext());
      let uri = Cc["@mozilla.org/network/io-service;1"].
                getService(Ci.nsIIOService).
                newURI("chrome://mochikit/content/chrome/toolkit/content/tests/chrome/", null, null);
      uri = cr.convertChromeURL(uri);
      let newChromePath = uri.QueryInterface(Ci.nsIFileURL).file;
      manifests.push(newChromePath);
      let provider = registerManifests(manifests);
      cr.checkForNewChrome();

      // Load plugin test pages in iframes
      let displayElement = document.getElementById("display");
      let frameLog = document.createElement("iframe");
      frameLog.setAttribute("style", "width: 400px; height: 400px");
      frameLog.setAttribute("src", "bug558403.logical.html");
      frameLog.addEventListener("load", function () {
          frameLog.removeEventListener("load", arguments.callee, false);

          snapshotFrame(frameLog, 1);
          let frameVis = document.createElement("iframe");
          frameVis.setAttribute("style", "width: 400px; height: 400px");
          frameVis.setAttribute("src", "bug558403.visual.html");
          frameVis.addEventListener("load", function () {
              frameVis.removeEventListener("load", arguments.callee, false);

              snapshotFrame(frameVis, 2);

            }, false);
          displayElement.appendChild(frameVis);
        }, false);
      displayElement.appendChild(frameLog);

    ]]>
  </script>

</window>

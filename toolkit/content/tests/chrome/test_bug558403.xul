<?xml version="1.0"?>
<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
<?xml-stylesheet 
  href="chrome://mochikit/content/tests/SimpleTest/test.css"
  type="text/css"?>
<!--
https://bugzilla.mozilla.org/show_bug.cgi?id=558403
-->
<window title="Mozilla Bug 558406"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <title>Test for Bug 558403</title>
  <script type="application/javascript" 
          src="chrome://mochikit/content/MochiKit/packed.js"></script>
  <script type="application/javascript" 
          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
  <script type="application/javascript"
          src="chrome://mochikit/content/tests/SimpleTest/WindowSnapshot.js"></script>
  <script type="application/javascript"
          src="RegisterUnregisterChrome.js"></script>

  <body  xmlns="http://www.w3.org/1999/xhtml">
    <a target="_blank" 
       href="https://bugzilla.mozilla.org/show_bug.cgi?id=558403">
      Mozilla Bug 558403
    </a>

    <p id="display">
    </p>
    <div id="content" style="display: none">
    </div>
    <pre id="test">
    </pre>
  </body>

  <script type="application/javascript">
    <![CDATA[

      // This code is adapted from reftest.js to add support for reftest-wait to WindowSnapshot
      function shouldWait(contentRootElement)
      {
        // use getAttribute because className works differently in HTML and SVG
        return contentRootElement &&
               contentRootElement.hasAttribute('class') &&
               contentRootElement.getAttribute('class').split(/\s+/)
                                 .indexOf("reftest-wait") != -1;
      }

      function snapshotFrame(frame, state) {
        var stopAfterPaintReceived = false;
        var currentDoc = frame.contentDocument;
        var utils = frame.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
            .getInterface(Ci.nsIDOMWindowUtils);
        contentRootElement = frame.contentDocument.documentElement;

        function InitCurrentCanvasWithSnapshot()
        {
          var win = frame.contentWindow;
          el = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          el.width = win.innerWidth;
          el.height = win.innerHeight;

          // drawWindow requires privileges
          netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');

          var ctx = el.getContext("2d");
          ctx.drawWindow(win, win.scrollX, win.scrollY,
                         win.innerWidth, win.innerHeight,
                         "rgb(255,255,255)",
                         ctx.DRAWWINDOW_DRAW_CARET);
          return el;
        }

        function DocumentLoaded()
        {
          if (state == 1) {
            s1 = InitCurrentCanvasWithSnapshot();
          } else if (state == 2) {
            s2 = InitCurrentCanvasWithSnapshot();
            [equal, str1, str2] = compareSnapshots(s1, s2, true);
            ok(equal, "logical and visual documents should be identical: expected " +
               str1 + " but got " + str2);
        
            SimpleTest.finish();
          }
        }

        function FlushRendering() {
            // Flush pending restyles and reflows
            contentRootElement.getBoundingClientRect();
            // Flush out invalidation
            utils.processUpdates();
        }

        function WhenMozAfterPaintFlushed(continuation) {
            if (utils.isMozAfterPaintPending) {
                function handler() {
                    frame.removeEventListener("MozAfterPaint", handler, false);
                    continuation();
                }
                frame.addEventListener("MozAfterPaint", handler, false);
            } else {
                continuation();
            }
        }

        function FinishWaitingForTestEnd() {
            setTimeout(DocumentLoaded, 0);
        }

        function AttrModifiedListener() {
            if (shouldWait())
                return;

            // We don't want to be notified again
            contentRootElement.removeEventListener("DOMAttrModified", AttrModifiedListener, false);
            // Wait for the next return-to-event-loop before continuing to flush rendering and
            // check isMozAfterPaintPending --- for example, the attribute may have been modified
            // in an subdocument's load event handler, in which case we need load event processing
            // to complete and unsuppress painting before we check isMozAfterPaintPending.
            setTimeout(AttrModifiedListenerContinuation, 0);
        }

        function AttrModifiedListenerContinuation() {
            FlushRendering();

            if (utils.isMozAfterPaintPending) {
                // Wait for the last invalidation to have happened and been snapshotted before
                // we stop the test
                stopAfterPaintReceived = true;
            } else {
                // Nothing to wait for, so stop now
                FinishWaitingForTestEnd();
            }
        }

        function StartWaitingForTestEnd() {
            FlushRendering();

            function continuation() {
                contentRootElement.addEventListener("DOMAttrModified", AttrModifiedListener, false); 

                if (!shouldWait()) {
                    // reftest-wait was already removed (during the interval between OnDocumentLoaded
                    // calling setTimeout(StartWaitingForTestEnd,0) below, and this function
                    // actually running), so let's fake a direct notification of the attribute
                    // change.
                    AttrModifiedListener();
                    return;
                }
            }
            WhenMozAfterPaintFlushed(continuation);
        }

        // After this load event has finished being dispatched, painting is normally
        // unsuppressed, which invalidates the entire window. So ensure
        // StartWaitingForTestEnd runs after that invalidation has been requested.
        setTimeout(StartWaitingForTestEnd, 0);
      }

    ]]>
  </script>

  <script class="testbody" type="application/javascript">
   <![CDATA[

   /** Test for Bug 558403 **/
    let prefs = Cc["@mozilla.org/preferences-service;1"].
                   getService(Ci.nsIPrefBranch);
    if (!prefs.getBoolPref("dom.ipc.plugins.enabled")) {
      todo(false, "Test requires OOPP");
    } else {
      SimpleTest.waitForExplicitFinish();

      registerManifestPermanently("chrome://mochikit/content/chrome/toolkit/content/tests/chrome/rtlchrome/righttoleft.manifest");

      // Load plugin test pages in iframes
      let displayElement = document.getElementById("display");
      let frameLog = document.createElement("iframe");
      frameLog.setAttribute("style", "width: 400px; height: 400px");
      frameLog.setAttribute("src", "bug558403.logical.html");
      frameLog.addEventListener("load", function () {
          frameLog.removeEventListener("load", arguments.callee, false);

          snapshotFrame(frameLog, 1);
          let frameVis = document.createElement("iframe");
          frameVis.setAttribute("style", "width: 400px; height: 400px");
          frameVis.setAttribute("src", "bug558403.visual.html");
          frameVis.addEventListener("load", function () {
              frameVis.removeEventListener("load", arguments.callee, false);

              snapshotFrame(frameVis, 2);

            }, false);
          displayElement.appendChild(frameVis);
        }, false);
      displayElement.appendChild(frameLog);
    }
   ]]>
  </script>
</window>

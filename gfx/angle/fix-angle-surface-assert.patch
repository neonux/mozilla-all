# HG changeset patch
# Parent 9869d707ee367a9a108b663c71388cdea4abb705

diff --git a/gfx/angle/src/libEGL/Surface.cpp b/gfx/angle/src/libEGL/Surface.cpp
--- a/gfx/angle/src/libEGL/Surface.cpp
+++ b/gfx/angle/src/libEGL/Surface.cpp
@@ -210,33 +210,33 @@ bool Surface::resetSwapChain(int backbuf
         }
 
         result = device->CreateTexture(presentParameters.BackBufferWidth, presentParameters.BackBufferHeight, 1, D3DUSAGE_RENDERTARGET,
                                        presentParameters.BackBufferFormat, D3DPOOL_DEFAULT, &mOffscreenTexture, pShareHandle);
     }
 
     if (FAILED(result))
     {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+      ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY || result == D3DERR_INVALIDCALL);
 
         ERR("Could not create additional swap chains or offscreen surfaces: %08lX", result);
         release();
         return error(EGL_BAD_ALLOC, false);
     }
 
     if (mConfig->mDepthStencilFormat != D3DFMT_UNKNOWN)
     {
         result = device->CreateDepthStencilSurface(presentParameters.BackBufferWidth, presentParameters.BackBufferHeight,
                                                    presentParameters.AutoDepthStencilFormat, presentParameters.MultiSampleType,
                                                    presentParameters.MultiSampleQuality, FALSE, &mDepthStencil, NULL);
     }
 
     if (FAILED(result))
     {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY || result == D3DERR_INVALIDCALL);
 
         ERR("Could not create depthstencil surface for new swap chain: %08lX", result);
         release();
         return error(EGL_BAD_ALLOC, false);
     }
 
     if (mWindow) {
         mSwapChain->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &mRenderTarget);

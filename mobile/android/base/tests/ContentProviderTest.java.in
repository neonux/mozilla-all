#filter substitution
package @ANDROID_PACKAGE_NAME@.tests;

import @ANDROID_PACKAGE_NAME@.*;

import android.content.ContentProvider;
import android.content.ContentProviderClient;
import android.content.ContentValues;
import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.os.Build;
import android.net.Uri;
import android.test.AndroidTestCase;
import android.test.IsolatedContext;
import android.test.ProviderTestCase2;
import android.test.RenamingDelegatingContext;
import android.test.mock.MockContentResolver;
import android.test.mock.MockContext;
import android.util.Log;

import java.io.File;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * ContentProviderTest provides the infrastructure to run content provider
 * tests in an controlled/isolated environment, guaranteeing that your tests
 * will not affect or be affected by any UI-related code. This is basically
 * a heavily adapted port of Android's ProviderTestCase2 to work on Mozilla's
 * infrastructure.
 */
abstract class ContentProviderTest extends AndroidTestCase {
    protected ContentProvider mProvider;
    protected MockContentResolver mResolver;
    protected Assert mAsserter;
    protected ClassLoader mClassLoader;
    protected ArrayList<Runnable> mTests;
    protected Class mProviderClass;
    protected Class mProviderContract;
    protected Uri mProviderAuthority;
    protected IsolatedContext mProviderContext;
    protected String mLogFile;

    private class ContentProviderMockContext extends MockContext {
        @Override
        public Resources getResources() {
            return getContext().getResources();
        }

        @Override
        public File getDir(String name, int mode) {
            return getContext().getDir(this.getClass().getSimpleName() + "_" + name, mode);
        }

        @Override
        public Context getApplicationContext() {
            return this;
        }
    }

    private void setUpProviderClassAndAuthority(String providerClassName,
            String authorityUriField) throws Exception {
        mProviderContract = mClassLoader.loadClass("org.mozilla.gecko.db.BrowserContract");
        mProviderAuthority = (Uri) mProviderContract.getField(authorityUriField).get(null);
        mProviderClass = mClassLoader.loadClass(providerClassName);
    }

    private void setUpContentProvider() throws Exception {
        mResolver = new MockContentResolver();

        final String filenamePrefix = this.getClass().getSimpleName() + ".";
        RenamingDelegatingContext targetContextWrapper =
                new RenamingDelegatingContext(
                    new ContentProviderMockContext(),
                    getContext(),
                    filenamePrefix);

        mProviderContext = new IsolatedContext(mResolver, targetContextWrapper);

        mProvider = (ContentProvider) mProviderClass.newInstance();
        mProvider.attachInfo(mProviderContext, null);

        mResolver.addProvider(mProviderAuthority.toString(), mProvider);
    }

    private void loadRobotiumConfig() {
        String configFile = FennecNativeDriver.getFile("/mnt/sdcard/robotium.config");
        HashMap config = FennecNativeDriver.convertTextToTable(configFile);
        mLogFile = (String) config.get("logfile");
    }

    public Uri getContentUri(String className) throws Exception {
        Class aClass = mClassLoader.loadClass("org.mozilla.gecko.db.BrowserContract$" + className);
        Uri contentUri = (Uri) aClass.getField("CONTENT_URI").get(null);
        return appendUriParam(contentUri, "PARAM_IS_TEST", "1");
    }

    public String getStringColumn(String className, String columnId) throws Exception {
        Class aClass = mClassLoader.loadClass("org.mozilla.gecko.db.BrowserContract$" + className);
        return (String) aClass.getField(columnId).get(null);
    }

    public int getIntColumn(String className, String columnId) throws Exception {
        Class aClass = mClassLoader.loadClass("org.mozilla.gecko.db.BrowserContract$" + className);
        Integer intColumn = (Integer) aClass.getField(columnId).get(null);
        return intColumn.intValue();
    }

    public Uri appendUriParam(Uri uri, String paramName, String value) throws Exception {
        String param = (String) mProviderContract.getField(paramName).get(null);
        return uri.buildUpon().appendQueryParameter(param, value).build();
    }

    public void setTestName(String testName) {
        mAsserter.setTestName(this.getClass().getName() + " - " + testName);
    }

    public void setTestType(String type) {
        if (type.equals("talos")) {
            mAsserter = new FennecTalosAssert();
        } else {
            mAsserter = new FennecMochitestAssert();
        }

        mAsserter.setLogFile(mLogFile);
        mAsserter.setTestName(this.getClass().getName());
    }

    public void setUp() throws Exception {
        throw new Exception("You should call setUp(providerClassName, authorityUriField) instead");
    }

    public void setUp(String providerClassName, String authorityUriField) throws Exception {
        super.setUp();

        mClassLoader = getContext().getClassLoader();
        mTests = new ArrayList<Runnable>();

        loadRobotiumConfig();
        setUpProviderClassAndAuthority(providerClassName, authorityUriField);
        setUpContentProvider();
    }

    public void tearDown() throws Exception {
        if (Build.VERSION.SDK_INT >= 11) {
            mProvider.shutdown();
        }

        String databaseName = null;
        try {
            Method getDatabasePath =
                    mProviderClass.getDeclaredMethod("getDatabasePath", String.class, boolean.class);

            String defaultProfile = (String) mProviderContract.getField("DEFAULT_PROFILE").get(null);
            databaseName = (String) getDatabasePath.invoke(mProvider, defaultProfile, true /* is test */);
        } catch (Exception e) {}

        if (databaseName != null)
            mProviderContext.deleteDatabase(databaseName);

        super.tearDown();
    }
}

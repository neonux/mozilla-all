<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - Peter Annema.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Peter Annema <disttsc@bart.nl> (Original Author of <browser>)
   -   Peter Parente <parente@cs.unc.edu>
   -   Christopher Thomas <cst@yecc.com>
   -   Michael Ventnor <m.ventnor@gmail.com>
   -   Arpad Borsos <arpad.borsos@googlemail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
  <!ENTITY % findBarDTD SYSTEM "chrome://global/locale/findbar.dtd" >
  %findBarDTD;
]>

<bindings id="remoteBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="remote-browser" extends="chrome://global/content/bindings/browser.xml#browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <property name="accessibleType" readonly="true">
        <getter>
          <![CDATA[
            throw "Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="autoscrollEnabled">
        <getter>
          <![CDATA[
            throw "Supports Remote?";
          ]]>
        </getter>
      </property>

      <field name="_searchEngines">[]</field>
      <property name="searchEngines"
                onget="return this._searchEngines"
                readonly="true"/>

      <property name="docShell"
                onget="throw 'Not Remotable'"
                readonly="true"/>

      <property name="messageManager"
                onget="return this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.messageManager;"
                readonly="true"/>

      <field name="_contentTitle">null</field>
      <field name="_contentDocument"><![CDATA[
        ({
          get title() { return this._browser._contentTitle; },
          get location() { return null; },
          set location(aURI) { this._browser.loadURI(aURI, null, null); },
          get nodePrincipal() { throw "Not Remotable"; },

          _browser: this,
        })
      ]]></field>

      <field name="_ios">
         Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
      </field>

      <field name="_webNavigation"><![CDATA[
        ({
          canGoBack: false,
          canGoForward: false,
          goBack: function() { this._sendSyncMessage("WebNavigation:GoBack", {}); },
          goForward: function() { this._sendSyncMessage("WebNavigation:GoForward", {}); },
          gotoIndex: function(aIndex) { this._sendSyncMessage("WebNavigation:GotoIndex", {index: aIndex}); },
          loadURI: function(aURI, aLoadFlags, aReferrer, aPostData, aHeaders) {
            this._currentURI = this._browser._ios.newURI(aURI, null, null);
            this._browser._contentTitle = "";
            this._sendSyncMessage("WebNavigation:LoadURI", {uri: aURI, flags: aLoadFlags});
          },
          reload: function(aReloadFlags) { this._sendSyncMessage("WebNavigation:Reload", {flags: aReloadFlags}); },
          stop: function(aStopFlags) { this._sendSyncMessage("WebNavigation:Stop", {flags: aStopFlags}); },
          get document() { return this._browser._contentDocument; },
          get currentURI() {
            if (!this._currentURI)
               this._currentURI = this._browser._ios.newURI("about:blank", null, null);

            return this._currentURI;
          },
          set currentURI(aURI) { this.loadURI(aURI.spec, null, null, null); },
          referringURI: null,
          get sessionHistory() { throw "Not Remoteable"; },

          _currentURI: null,
          _browser: this,
          _sendSyncMessage: function(aMessage, aData) {
            try {
              this._browser.messageManager.sendAsyncMessage(aMessage, aData);
            }
            catch (e) {
              Components.utils.reportError(e);
            }
         }
        })
      ]]></field>

      <property name="webNavigation"
                onget="return this._webNavigation;"
                readonly="true"/>

      <method name="receiveMessage">
        <parameter name="aMessage"/>
        <body><![CDATA[
          switch (aMessage.name) {
            case "DOMContentLoaded": {
              let data = aMessage.json;
              if (this.mIconURL == "") {
                let documentURI = gIOService.newURI(data.location, null, null);
                this.mIconURL = documentURI.prePath + "/favicon.ico";
              }
              break;
            }
            case "DOMTitleChanged": {
              this._contentTitle = aMessage.json.title;

              let event = document.createEvent("Events");
              event.initEvent("DOMTitleChanged", true, true);
              this.dispatchEvent(event);
              break;
            }
            case "DOMWillOpenModalDialog": {
              let event = document.createEvent("Events");
              event.initEvent("DOMWillOpenModalDialog", true, true);
              this.dispatchEvent(event);
              break;
            }
            case "DOMWindowClose": {
              let event = document.createEvent("Events");
              event.initEvent("DOMWindowClose", true, true);
              this.dispatchEvent(event);
              break;
            }
            case "DOMLinkAdded": {
              let link = aMessage.json;
              if (!link.isRootDocument)
                return;

              let linkType = this._getLinkType(link);
              switch(linkType) {
                case "icon":
                  let iconURI = gIOService.newURI(link.href, link.characterSet, null);
                  if (!iconURI.schemeIs("javascript") && !gFaviconService.isFailedFavicon(iconURI)) {
                    gFaviconService.setAndLoadFaviconForPage(this.currentURI, iconURI, true);
                    this.mIconURL = iconURI.spec;
                  }
                  break;
                case "search":
                  this._searchEngines.push({ title: link.title, href: link.href });
                  break;
              }
              break;
            }
         }
        ]]></body>
      </method>

      <method name="_getLinkType">
        <parameter name="aLink" />
        <body><![CDATA[
          let type = "";
          if (/\bicon\b/i(aLink.rel)) {
            type = "icon";
          }
          else if (/\bsearch\b/i(aLink.rel) && aLink.type && aLink.title) {
            let linkType = aLink.type.replace(/^\s+|\s*(?:;.*)?$/g, "").toLowerCase();
            if (linkType == "application/opensearchdescription+xml" && /^(?:https?|ftp):/i.test(aLink.href)) {
              type = "search";
            }
          }

          return type;
        ]]></body>
      </method>

      <field name="_webBrowserFind">null</field>

      <property name="webBrowserFind"
                readonly="true">
        <getter>
        <![CDATA[
          return this._webBrowserFind;
        ]]>
        </getter>
      </property>

      <field name="_fastFind">null</field>
      <property name="fastFind"
                readonly="true">
        <getter>
        <![CDATA[
          return this._fastFind;
        ]]>
        </getter>
      </property>

      <field name="_webProgress"><![CDATA[
        ({
          _listeners: [],
          _browser: this,

          _init: function() {
            this._browser.messageManager.addMessageListener("WebProgress:StateChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:ProgressChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:LocationChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:StatusChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:SecurityChange", this);
          },

          addProgressListener: function(aListener, aNotifyFlags) {
            function hasFilter(item) {
              return item.listener == aListener;
            }
        
            if (this._listeners.some(hasFilter))
              return;
        
            this._listeners.push({
              listener: aListener,
              flags: aNotifyFlags
            });
          },

          removeProgressListener: function(aListener) {
            function hasFilter(item) {
              return item.listener != aListener;
            }
        
            this._listeners = this._listeners.filter(hasFilter);
          },
          get DOMWindow() { throw "Not Remoteable" },
          isLoadingDocument: false,
          
          receiveMessage: function(aMessage) {
            let args;
            switch (aMessage.name) {
              case "WebProgress:StateChange":
                args = [
                  { isRootWindow: aMessage.json.isRootWindow, browser: this.browser },
                  {},
                  aMessage.json.stateFlags,
                  aMessage.json.status
                ];
                this._notify(aMessage.json.notifyFlags, "onStateChange", args);
                break;
 
              case "WebProgress:ProgressChange":
                args = [
                  { isRootWindow: aMessage.json.isRootWindow, browser: this.browser },
                  {},
                  aMessage.json.curSelf,
                  aMessage.json.maxSelf,
                  aMessage.json.curTotal,
                  aMessage.json.maxTotal
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_PROGRESS,
                             "onProgressChange",
                             args);
                break;
 
              case "WebProgress:LocationChange":
                let currentURI = this._browser._ios.newURI(aMessage.json.location, null, null);
                this._browser._webNavigation._currentURI = currentURI;
                this._browser._webNavigation.canGoBack = aMessage.json.canGoBack;
                this._browser._webNavigation.canGoForward = aMessage.json.canGoForward;

                args = [
                  { isRootWindow: aMessage.json.isRootWindow, browser: this.browser },
                  {},
                  currentURI
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_LOCATION,
                             "onLocationChange",
                             args);

                this._browser._searchEngines = [];
                break;
 
              case "WebProgress:StatusChange":
                args = [
                  { isRootWindow: aMessage.json.isRootWindow, browser: this.browser },
                  {},
                  aMessage.json.status,
                  aMessage.json.message
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_STATUS,
                             "onStatusChange",
                             args);
                break;
 
              case "WebProgress:SecurityChange":
                args = [
                  { isRootWindow: aMessage.json.isRootWindow, browser: this.browser, identity: aMessage.json.identity },
                  {},
                  aMessage.json.state
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_SECURITY,
                             "onSecurityChange",
                             args);
                break;
            }

            return {};
          },
          
          _notify: function(aFlags, aName, aArguments) {
            this._listeners.forEach(function(item) {
              if (item.flags & aFlags)
                item.listener[aName].apply(item.listener, aArguments);
            });
          }
        })
      ]]></field>

      <property name="webProgress"
                readonly="true"
                onget="return this._webProgress"/>

      <property name="contentWindow"
                readonly="true"
                onget="throw 'Not Remoteable'"/>

      <property name="sessionHistory"
                onget="throw 'Not Remoteable'"
                readonly="true"/>

      <property name="markupDocumentViewer"
                onget="throw 'Not Remoteable'"
                readonly="true"/>

      <property name="contentViewerEdit"
                onget="throw 'Not Remoteable'"
                readonly="true"/>

      <property name="contentViewerFile"
                onget="throw 'Not Remoteable'"
                readonly="true"/>

      <property name="documentCharsetInfo"
                onget="throw 'Not Remoteable'"
                readonly="true"/>

      <method name="attachFormFill">
        <body>
          <![CDATA[
          if (!this.mFormFillAttached && this.hasAttribute("autocompletepopup")) {
            // hoop up the form fill autocomplete controller
            var controller = Components.classes["@mozilla.org/satchel/form-fill-controller;1"].
                               getService(Components.interfaces.nsIFormFillController);

            var popup = document.getElementById(this.getAttribute("autocompletepopup"));
            if (popup) {
              controller.attachToBrowser(this.docShell, popup.QueryInterface(Components.interfaces.nsIAutoCompletePopup));
              this.mFormFillAttached = true;
            }
          }
          ]]>
        </body>
      </method>

      <method name="detachFormFill">
        <body>
          <![CDATA[
          if (this.mFormFillAttached) {
            // hoop up the form fill autocomplete controller
            var controller = Components.classes["@mozilla.org/satchel/form-fill-controller;1"].
                               getService(Components.interfaces.nsIFormFillController);
            controller.detachFromBrowser(this.docShell);
            
            this.mFormFillAttached = false;
          }
          ]]>
        </body>
      </method>
      
      <method name="findChildShell">
        <parameter name="aDocShell"/>
        <parameter name="aSoughtURI"/>
        <body>
          <![CDATA[
            if (aDocShell.QueryInterface(Components.interfaces.nsIWebNavigation)
                         .currentURI.spec == aSoughtURI.spec)
              return aDocShell;
            var node = aDocShell.QueryInterface(
                                   Components.interfaces.nsIDocShellTreeNode);
            for (var i = 0; i < node.childCount; ++i) {
              var docShell = node.getChildAt(i);
              docShell = this.findChildShell(docShell, aSoughtURI);
              if (docShell)
                return docShell;
            }
            return null;
          ]]>
        </body>
      </method>

      <method name="onPageShow">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            this.attachFormFill();
            if (this.pageReport) {
              var i = 0;
              while (i < this.pageReport.length) {
                // Filter out irrelevant reports.
                if (this.pageReport[i].requestingWindow &&
                    (this.pageReport[i].requestingWindow.document ==
                     this.pageReport[i].requestingDocument))
                  i++;
                else
                  this.pageReport.splice(i, 1);
              }
              if (this.pageReport.length == 0) {
                this.pageReport = null;
                this.updatePageReport();
              }
            }
         ]]>
        </body>
      </method>

      <method name="onPageHide">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            if (this.pageReport) {
              this.pageReport = null;
              this.updatePageReport();
            }
            // Delete the feeds cache if we're hiding the topmost page
            // (as opposed to one of its iframes).
            if (this.feeds && aEvent.target == this.contentDocument)
              this.feeds = null;
            if (!this.docShell || !this.fastFind)
              return;
            var tabBrowser = this.getTabBrowser();
            if (!tabBrowser || tabBrowser.mCurrentBrowser == this)
              this.fastFind.setDocShell(this.docShell);

            if (this._scrollable)
              this._autoScrollPopup.hidePopup();
         ]]>
        </body>
      </method>

      <method name="updatePageReport">
        <body>
          <![CDATA[
            var event = document.createEvent("Events");
            event.initEvent("DOMUpdatePageReport", true, true);
            this.dispatchEvent(event);
          ]]>
        </body>
      </method>

      <method name="onPopupBlocked">
        <parameter name="evt"/>
        <body>
          <![CDATA[
            if (!this.pageReport) {
              this.pageReport = new Array();
            }

            var obj = { requestingWindow: evt.requestingWindow,
                        // Record the current document in the requesting window
                        // before it can change.
                        requestingDocument: evt.requestingWindow.document,
                        popupWindowURI: evt.popupWindowURI,
                        popupWindowFeatures: evt.popupWindowFeatures,
                        popupWindowName: evt.popupWindowName };

            this.pageReport.push(obj);
            this.pageReport.reported = false;
            this.updatePageReport();
          ]]> 
        </body>
      </method>

      <field name="pageReport">null</field>

      <property name="securityUI">
        <getter>
          <![CDATA[
            if (!this.docShell.securityUI) {
              const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
              if (!this.hasAttribute("disablesecurity") &&
                  SECUREBROWSERUI_CONTRACTID in Components.classes) {
                var securityUI = Components.classes[SECUREBROWSERUI_CONTRACTID]
                                           .createInstance(Components.interfaces.nsISecureBrowserUI);
                securityUI.init(this.contentWindow);
              }
            }
            
            return this.docShell.securityUI;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            this.docShell.securityUI = val;
          ]]>
        </setter>
      </property>

      <constructor>
        <![CDATA[
          try {
            if (!this.hasAttribute("disablehistory")) {
              var os = Components.classes["@mozilla.org/observer-service;1"]
                                 .getService(Components.interfaces.nsIObserverService);
              os.addObserver(this, "browser:purge-session-history", false);
              // wire up session history
              this.webNavigation.sessionHistory = 
                      Components.classes["@mozilla.org/browser/shistory;1"]
                                .createInstance(Components.interfaces.nsISHistory);
              // enable global history
              this.docShell.QueryInterface(Components.interfaces.nsIDocShellHistory).useGlobalHistory = true;
            }
          }
          catch (e) {
            Components.utils.reportError(e);
          }
          try {
            var securityUI = this.securityUI;
          }
          catch (e) {
          }

          // Listen for first load for lazy attachment to form fill controller
          this.addEventListener("pageshow", this.onPageShow, true);
          this.addEventListener("pagehide", this.onPageHide, true);
          this.addEventListener("DOMPopupBlocked", this.onPopupBlocked, true);

          messageManager.loadFrameScript("chrome://browser/content/bindings/browser.js", true);
          //messageManager.addMessageListener("pageshow", this.onPageShow);
          //messageManager.addMessageListener("pagehide", this.onPageShow);
          //messageManager.addMessageListener("DOMPopupBlocked", this.onPopupBlocked);
          messageManager.addMessageListener("DOMContentLoaded", this);
          messageManager.addMessageListener("DOMTitleChanged", this);
          messageManager.addMessageListener("DOMLinkAdded", this);

          this.webProgress._init();
        ]]>
      </constructor>
      
      <destructor>
        <![CDATA[
          this.destroy();
        ]]>
      </destructor>

      <!-- This is necessary because the destructor doesn't always get called when
           we are removed from a tabbrowser. This will be explicitly called by tabbrowser -->
      <method name="destroy">
        <body>
          <![CDATA[
          if (this.mDestroyed)
            return;
          this.mDestroyed = true;

          if (!this.hasAttribute("disablehistory")) {
            var os = Components.classes["@mozilla.org/observer-service;1"]
                               .getService(Components.interfaces.nsIObserverService);
            try {
              os.removeObserver(this, "browser:purge-session-history");
            } catch (ex) {
              // It's not clear why this sometimes throws an exception.
            }
          }

          this.detachFormFill();
          
          this._fastFind = null;
          this._webBrowserFind = null;
          
          // The feeds cache can keep the document inside this browser alive.
          this.feeds = null;

          this.lastURI = null;

          this.removeEventListener("pageshow", this.onPageShow, true);
          this.removeEventListener("pagehide", this.onPageHide, true);
          this.removeEventListener("DOMPopupBlocked", this.onPopupBlocked, true);

          if (this._autoScrollNeedsCleanup) {
            // we polluted the global scope, so clean it up
            this._autoScrollPopup.parentNode.removeChild(this._autoScrollPopup);
          }
          ]]>
        </body>
      </method>
      
      <method name="observe">
        <parameter name="aSubject"/>
        <parameter name="aTopic"/>
        <parameter name="aState"/>
        <body>
          <![CDATA[
            if (aTopic != "browser:purge-session-history" || !this.sessionHistory)
              return;
              
            // place the entry at current index at the end of the history list, so it won't get removed
            if (this.sessionHistory.index < this.sessionHistory.count - 1) {
              var indexEntry = this.sessionHistory.getEntryAtIndex(this.sessionHistory.index, false);
              this.sessionHistory.QueryInterface(Components.interfaces.nsISHistoryInternal);
              indexEntry.QueryInterface(Components.interfaces.nsISHEntry);
              this.sessionHistory.addEntry(indexEntry, true);
            }
            
            var purge = this.sessionHistory.count;
            if (this.currentURI != "about:blank")
              --purge; // Don't remove the page the user's staring at from shistory
            
            if (purge > 0)
              this.sessionHistory.PurgeHistory(purge);
          ]]>
        </body>
      </method>

      <method name="swapDocShells">
        <parameter name="aOtherBrowser"/>
        <body>
        <![CDATA[
          // We need to swap fields that are tied to our docshell or related to
          // the loaded page
          // Fields which are built as a result of notifactions (pageshow/hide,
          // DOMLinkAdded/Removed, onStateChange) should not be swapped here,
          // because these notifications are dispatched again once the docshells
          // are swapped.
          var fieldsToSwap = [ "_docShell", "_webBrowserFind", "_contentWindow", "_webNavigation"];

          var ourTabBrowser = this.getTabBrowser();

          // _fastFind is tied to the docshell if we don't have a tabbrowser
          if ((ourTabBrowser != null) !=
              (aOtherBrowser.getTabBrowser() != null))
            throw "Unable to perform swap on <browsers> if one is in a <tabbrowser> and one is not";

          if (!ourTabBrowser)
            fieldsToSwap.push("_fastFind");

          var ourFieldValues = {};
          var otherFieldValues = {};
          for each (var field in fieldsToSwap) {
            ourFieldValues[field] = this[field];
            otherFieldValues[field] = aOtherBrowser[field];
          }
          this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner)
              .swapFrameLoaders(aOtherBrowser);
          for each (var field in fieldsToSwap) {
            this[field] = otherFieldValues[field];
            aOtherBrowser[field] = ourFieldValues[field];
          }
        ]]>
        </body>
      </method>
    </implementation>

  </binding>

</bindings>

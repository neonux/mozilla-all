<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - Peter Annema.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Peter Annema <disttsc@bart.nl> (Original Author of <browser>)
   -   Peter Parente <parente@cs.unc.edu>
   -   Christopher Thomas <cst@yecc.com>
   -   Michael Ventnor <m.ventnor@gmail.com>
   -   Arpad Borsos <arpad.borsos@googlemail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
  <!ENTITY % findBarDTD SYSTEM "chrome://global/locale/findbar.dtd" >
  %findBarDTD;
]>

<bindings id="remoteBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="local-browser" extends="chrome://global/content/bindings/browser.xml#browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <field name="_securityUI">null</field>
      <property name="securityUI">
        <getter><![CDATA[
          if (!this._securityUI) {
            const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
            if (!this.hasAttribute("disablesecurity") && SECUREBROWSERUI_CONTRACTID in Components.classes) {
              this.messageManager.sendAsyncMessage('SecurityUI:Init', { });
            }
          }

          return this._securityUI || {};
        ]]></getter>
        <setter><![CDATA[
          this._securityUI = val;
        ]]></setter>
      </property>

      <field name="_searchEngines">[]</field>
      <property name="searchEngines"
                onget="return this._searchEngines"
                readonly="true"/>

      <field name="_documentURI">null</field>
      <property name="documentURI"
                onget="return Services.io.newURI(this._documentURI, null, null)"
                readonly="true"/>

      <field name="contentWindowId">null</field>

      <property name="messageManager"
                onget="return this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.messageManager;"
                readonly="true"/>

      <field name="_contentTitle">null</field>

      <field name="_ios">
         Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
      </field>

      <method name="receiveMessage">
        <parameter name="aMessage"/>
        <body><![CDATA[
          switch (aMessage.name) {
            case "DOMPopupBlocked":
              this.onPopupBlocked(aMessage);
              break;

            case "pageshow":
              this.onPageShow(aMessage);

              if (this.mIconURL == "" && this._documentURI) {
                // newURI call is throwing for chrome URI
                try {
                  // Use documentURIObject in the favicon construction so that we
                  // do the right thing with about:-style error pages.  Bug 515188
                  let iconURI = Services.io.newURI(this.documentURI.prePath + "/favicon.ico", null, null);
                  if (!iconURI.schemeIs("javascript") && !gFaviconService.isFailedFavicon(iconURI)) {
                    gFaviconService.setAndLoadFaviconForPage(this.currentURI, iconURI, true);
                    this.mIconURL = iconURI.spec;
                  }
                }
                catch(e) {}
              }
              break;

            case "pagehide":
              this.onPageHide(aMessage);
              break;

            case "DOMTitleChanged":
              this._contentTitle = aMessage.json.title;
              break;

            case "DOMLinkAdded":
              let link = aMessage.json;
              // ignore results from subdocuments
              if (link.windowId != this.contentWindowId)
                return;

              let linkType = this._getLinkType(link);
              switch(linkType) {
                case "icon":
                  let iconURI = Services.io.newURI(link.href, link.charset, null);
                  if (!iconURI.schemeIs("javascript") && !gFaviconService.isFailedFavicon(iconURI)) {
                    gFaviconService.setAndLoadFaviconForPage(this.currentURI, iconURI, true);
                    this.mIconURL = iconURI.spec;
                  }
                  break;
                case "search":
                  this._searchEngines.push({ title: link.title, href: link.href });
                  break;
              }
              break;

            case "Prompt:Alert":
              alert(aMessage.json.message);
              break;

            case "Prompt:Confirm":
              return confirm(aMessage.json.message);

            case "Prompt:Prompt":
              return prompt(aMessage.json.text, aMessage.json.value);

            case "MozScrolledAreaChanged":
              this._widthInCSSPx = aMessage.json.width;
              this._heightInCSSPx = aMessage.json.height;
              this._viewportWidthInCSSPx = aMessage.json.viewportWidth;
              this._viewportHeightInCSSPx = aMessage.json.viewportHeight;
              this._updateCacheViewport();
              break;
         }
        ]]></body>
      </method>

      <method name="_getLinkType">
        <parameter name="aLink" />
        <body><![CDATA[
          let type = "";
          if (/\bicon\b/i(aLink.rel)) {
            type = "icon";
          }
          else if (/\bsearch\b/i(aLink.rel) && aLink.type && aLink.title) {
            let linkType = aLink.type.replace(/^\s+|\s*(?:;.*)?$/g, "").toLowerCase();
            if (linkType == "application/opensearchdescription+xml" && /^(?:https?|ftp):/i.test(aLink.href)) {
              type = "search";
            }
          }

          return type;
        ]]></body>
      </method>

      <field name="_webProgress"><![CDATA[
        ({
          _listeners: [],
          _browser: this,

          _init: function() {
            this._browser.messageManager.addMessageListener("WebProgress:StateChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:ProgressChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:LocationChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:StatusChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:SecurityChange", this);
          },

          addProgressListener: function(aListener, aNotifyFlags) {
            function hasFilter(item) {
              return item.listener == aListener;
            }

            if (this._listeners.some(hasFilter))
              return;

            this._listeners.push({
              listener: aListener,
              flags: aNotifyFlags
            });

            this._browser.messageManager.sendAsyncMessage("WebProgress:AddProgressListener", {
              notifyFlags: aNotifyFlags,
            });
          },

          removeProgressListener: function(aListener) {
            let self = this;
            function hasFilter(item) {
              if (item.listener == aListener)
                self._browser.messageManager.sendAsyncMessage("WebProgress:RemoveProgressListener", {
                  notifyFlags: item.flags,
                });
              return item.listener != aListener;
            }

            this._listeners = this._listeners.filter(hasFilter);
          },
          get DOMWindow() { throw "DOMWindow: Not Remoteable" },
          get isLoadingDocument() { throw "isLoadingDocument: Not Remoteable"; },

          receiveMessage: function(aMessage) {
            let args;
            let json = aMessage.json;
            switch (aMessage.name) {
              case "WebProgress:StateChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.stateFlags,
                  json.status
                ];

                this._notify(json.notifyFlags, "onStateChange", args);
                break;

              case "WebProgress:ProgressChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.curSelf,
                  json.maxSelf,
                  json.curTotal,
                  json.maxTotal
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_PROGRESS,
                             "onProgressChange",
                             args);
                break;

              case "WebProgress:LocationChange":
                let locationURI = this._browser._ios.newURI(json.location, null, null);

                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  locationURI
                ];

                if (this._browser.contentWindowId != json.windowId) {
                  this._browser.contentWindowId = json.windowId;
                  this._browser._documentURI = json.documentURI;
                  this._browser._searchEngines = [];
                }

                this._browser._zoomLevel = 1;
                this._browser._updateCacheViewport();

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_LOCATION,
                             "onLocationChange",
                             args);

                break;

              case "WebProgress:StatusChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.status,
                  json.message
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_STATUS,
                             "onStatusChange",
                             args);
                break;

              case "WebProgress:SecurityChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.state
                ];

                this._browser._securityUI = {
                  SSLStatus: json.SSLStatus,
                  state: json.state
                }

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_SECURITY,
                             "onSecurityChange",
                             args);
                break;
            }
          },

          _notify: function(aFlags, aName, aArguments) {
            this._listeners.forEach(function(item) {
              if (item.flags & aFlags) {
                item.listener[aName].apply(item.listener, aArguments);
              }
            });
          }
        })
      ]]></field>

      <property name="webProgress"
                readonly="true"
                onget="return this._webProgress"/>

      <method name="onPageShow">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            this.attachFormFill();
            if (this.pageReport) {
              var json = aMessage.json;
              var i = 0;
              while (i < this.pageReport.length) {
                // Filter out irrelevant reports.
                if (this.pageReport[i].requestingWindowId == json.windowId)
                  i++;
                else
                  this.pageReport.splice(i, 1);
              }
              if (this.pageReport.length == 0) {
                this.pageReport = null;
                this.updatePageReport();
              }
            }
         ]]>
        </body>
      </method>

      <method name="onPageHide">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            if (this.pageReport) {
              this.pageReport = null;
              this.updatePageReport();
            }
            // Delete the feeds cache if we're hiding the topmost page
            // (as opposed to one of its iframes).
            if (this.feeds && aMessage.target == this)
              this.feeds = null;
         ]]>
        </body>
      </method>

      <method name="onPopupBlocked">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            if (!this.pageReport) {
              this.pageReport = [];
            }

            let json = aMessage.json;
            // XXX Replacing requestingWindow && requestingDocument affects
            // http://mxr.mozilla.org/mozilla-central/source/browser/base/content/browser.js#500
            var obj = {
              requestingWindowId: json.windowId,
              popupWindowURI: Services.io.newURI(json.popupWindowURI.spec, json.popupWindowURI.charset, null),
              popupWindowFeatures: json.popupWindowFeatures,
              popupWindowName: json.popupWindowName
            };

            this.pageReport.push(obj);
            this.pageReport.reported = false;
            this.updatePageReport();
          ]]>
        </body>
      </method>

      <field name="_frameLoader">null</field>

      <!-- Dimensions of content window -->
      <property name="viewportWidthInCSSPx"
                onget="return this._viewportWidthInCSSPx;"
                readonly="true"/>
      <property name="viewportHeightInCSSPx"
                onget="return this._viewportHeightInCSSPx;"
                readonly="true"/>

      <!-- Dimensions of content document -->
      <field name="_widthInCSSPx">0</field>
      <field name="_heightInCSSPx">0</field>
      <property name="_widthInDevicePx"
                onget="return this._widthInCSSPx * this._zoomLevel;"
                readonly="true"/>
      <property name="_heightInDevicePx"
                onget="return this._heightInCSSPx * this._zoomLevel;"
                readonly="true"/>

      <!-- Zoom level is the ratio of device pixels to CSS pixels -->
      <field name="_zoomLevel">1</field>
      <property name="scale"
                onget="return this._zoomLevel;"
                readonly="true"/>

      <!-- These counters are used to update the cached viewport after they reach a certain
           threshold when scrolling -->
      <field name="_pendingPixelsX">0</field>
      <field name="_pendingPixelsY">0</field>
      <field name="_pendingThresholdX">0</field>
      <field name="_pendingThresholdY">0</field>
      <!-- This determines what percentage of cached pixels are not yet visible before the cache
           is refreshed. For instance, if we recached at 50% and there are originally a total of
           400px offscreen, we'd refresh once 200 of those pixels have been scrolled into
           view. -->
      <field name="_recacheRatio">0</field>

      <!-- The cache viewport is what parts of content is cached in the parent process for
           fast scrolling. This syncs that up with the current projection viewport. -->
      <method name="_updateCacheViewport">
        <body>
          <![CDATA[
            let offscreenX = this._pendingThresholdX / this._recacheRatio;
            let offscreenY = this._pendingThresholdY / this._recacheRatio;

            let frameLoader = this._frameLoader;
            this.messageManager.sendAsyncMessage("Content:SetCacheViewport", {
              x: (frameLoader.viewportScrollX - offscreenX) / this._zoomLevel,
              y: (frameLoader.viewportScrollY - offscreenY) / this._zoomLevel,
              w: (this._viewportWidthInCSSPx + offscreenX * 2) / this._zoomLevel,
              h: (this._viewportHeightInCSSPx + offscreenY * 2) / this._zoomLevel,
              zoomLevel: this._zoomLevel
            });

            this._pendingPixelsX = 0;
            this._pendingPixelsY = 0;
          ]]>
        </body>
      </method>

      <!-- Synchronize the CSS viewport with the projection viewport. -->
      <method name="_updateCSSViewport">
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            this.messageManager.sendAsyncMessage("Content:ScrollTo", {
              x: frameLoader.viewportScrollX / this._zoomLevel,
              y: frameLoader.viewportScrollY / this._zoomLevel
            });
          ]]>
        </body>
      </method>

      <!-- Sets the scale of CSS pixels to device pixels. Does not affect page layout. -->
      <method name="setScale">
        <parameter name="zl"/>
        <body>
          <![CDATA[
            if (zl <= 0) throw "Bad zoom level given.";

            this._zoomLevel = zl;
            this._frameLoader.setViewportScale(zl, zl);
            this._updateCacheViewport();
          ]]>
        </body>
      </method>

      <!-- Sets size of CSS viewport, which affects how page is layout. -->
      <method name="setCssViewportSize">
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
          <![CDATA[
            this.messageManager.sendAsyncMessage("Content:SetCssViewportSize", {
              width: width,
              height: height
            });
          ]]>
        </body>
      </method>

      <!-- Scroll viewport by (x, y) device pixels. -->
      <method name="scrollBy">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            this.contentWindow.scrollBy(x, y);
          ]]>
        </body>
      </method>

      <!-- Scroll viewport to (x, y) offset of document in device pixels. -->
      <method name="scrollTo">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            this.contentWindow.scrollTo(x, y);
          ]]>
        </body>
      </method>

      <!-- Get position of viewport in device pixels. -->
      <method name="getPosition">
        <parameter name="scrollX"/>
        <parameter name="scrollY"/>
        <body>
          <![CDATA[
            let cwu = this.contentWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).
                      getInterface(Components.interfaces.nsIDOMWindowUtils);
            cwu.getScrollXY(false, scrollX, scrollY);
          ]]>
        </body>
      </method>

      <constructor>
        <![CDATA[
          this._frameLoader = this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader;

          let prefService = Components.classes["@mozilla.org/preferences-service;1"]
                                              .getService(Components.interfaces.nsIPrefService)
                                              .QueryInterface(Components.interfaces.nsIPrefBranch2);

          this._recacheRatio = Math.max(.01, Math.min(1, prefService.getIntPref("toolkit.browser.recacheRatio") / 100));
          this._pendingThresholdX = Math.max(0, prefService.getIntPref("toolkit.browser.cachePixelX")) * this._recacheRatio;
          this._pendingThresholdY = Math.max(0, prefService.getIntPref("toolkit.browser.cachePixelY")) * this._recacheRatio;

          this.messageManager.loadFrameScript("chrome://browser/content/bindings/browser.js", true);
          this.messageManager.addMessageListener("DOMTitleChanged", this);
          this.messageManager.addMessageListener("DOMLinkAdded", this);

          // Listen for first load for lazy attachment to form fill controller
          this.messageManager.addMessageListener("pageshow", this);
          this.messageManager.addMessageListener("pagehide", this);
          this.messageManager.addMessageListener("DOMPopupBlocked", this);

          // Prompt remoting
          ["Alert", "Confirm", "Prompt"].forEach(function(name) {
            this.messageManager.addMessageListener("Prompt:Alert" + name, this);
          }, this);

          this.messageManager.addMessageListener("MozScrolledAreaChanged", this);

          this._webProgress._init();
        ]]>
      </constructor>

    </implementation>

  </binding>

  <binding id="remote-browser" extends="#local-browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <property name="accessibleType" readonly="true">
        <getter>
          <![CDATA[
            throw "accessibleType: Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="autoscrollEnabled">
        <getter>
          <![CDATA[
            throw "autoscrollEnabled: Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="docShell"
                onget="throw 'docShell: Not Remotable'"
                readonly="true"/>

      <field name="_contentTitle">null</field>

      <property name="contentTitle"
                onget="return this._contentTitle;"
                readonly="true"/>

      <field name="_webNavigation"><![CDATA[
        ({
          LOAD_FLAGS_MASK: 65535,
          LOAD_FLAGS_NONE: 0,
          LOAD_FLAGS_IS_REFRESH: 16,
          LOAD_FLAGS_IS_LINK: 32,
          LOAD_FLAGS_BYPASS_HISTORY: 64,
          LOAD_FLAGS_REPLACE_HISTORY: 128,
          LOAD_FLAGS_BYPASS_CACHE: 256,
          LOAD_FLAGS_BYPASS_PROXY: 512,
          LOAD_FLAGS_CHARSET_CHANGE: 1024,
          LOAD_FLAGS_STOP_CONTENT: 2048,
          LOAD_FLAGS_FROM_EXTERNAL: 4096,
          LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP: 8192,
          LOAD_FLAGS_FIRST_LOAD: 16384,
          LOAD_FLAGS_ALLOW_POPUPS: 32768,
          LOAD_FLAGS_BYPASS_CLASSIFIER: 65536,
          LOAD_FLAGS_FORCE_ALLOW_COOKIES: 131072,

          STOP_NETWORK: 1,
          STOP_CONTENT: 2,
          STOP_ALL: 3,

          canGoBack: false,
          canGoForward: false,
          goBack: function() { this._sendMessage("WebNavigation:GoBack", {}); },
          goForward: function() { this._sendMessage("WebNavigation:GoForward", {}); },
          gotoIndex: function(aIndex) { this._sendMessage("WebNavigation:GotoIndex", {index: aIndex}); },
          loadURI: function(aURI, aLoadFlags, aReferrer, aPostData, aHeaders) {
            try {
              this._currentURI = this._browser._ios.newURI(aURI, null, null);
            } catch(e) {}
            this._browser._contentTitle = "";
            this._sendMessage("WebNavigation:LoadURI", {uri: aURI, flags: aLoadFlags});
          },
          reload: function(aReloadFlags) { this._sendMessage("WebNavigation:Reload", {flags: aReloadFlags}); },
          stop: function(aStopFlags) { this._sendMessage("WebNavigation:Stop", {flags: aStopFlags}); },
          get document() { Components.utils.reportError("contentDocument is not available"); return null; },
          get currentURI() {
            if (!this._currentURI)
               this._currentURI = this._browser._ios.newURI("about:blank", null, null);

            return this._currentURI;
          },
          set currentURI(aURI) { this.loadURI(aURI.spec, null, null, null); },
          referringURI: null,
          get sessionHistory() { return null; },
          set sessionHistory(aValue) { },

          _currentURI: null,
          _browser: this,
          _sendMessage: function(aMessage, aData) {
            try {
              this._browser.messageManager.sendAsyncMessage(aMessage, aData);
            }
            catch (e) {
              Components.utils.reportError(e);
            }
         },

         QueryInterface: function(aIID) {
           if (aIID.equals(Components.interfaces.nsIWebNavigation) || aIID.equals(Components.interfaces.nsISupports))
             return this;
           throw Components.results.NS_NOINTERFACE;
         }
        })
      ]]></field>

      <property name="webNavigation"
                onget="return this._webNavigation;"
                readonly="true"/>

      <field name="_webProgress"><![CDATA[
        ({
          _listeners: [],
          _browser: this,

          _init: function() {
            this._browser.messageManager.addMessageListener("WebProgress:StateChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:ProgressChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:LocationChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:StatusChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:SecurityChange", this);
          },

          addProgressListener: function(aListener, aNotifyFlags) {
            function hasFilter(item) {
              return item.listener == aListener;
            }

            if (this._listeners.some(hasFilter))
              return;

            this._listeners.push({
              listener: aListener,
              flags: aNotifyFlags
            });
          },

          removeProgressListener: function(aListener) {
            function hasFilter(item) {
              return item.listener != aListener;
            }

            this._listeners = this._listeners.filter(hasFilter);
          },
          get DOMWindow() { throw "DOMWindow: Not Remoteable" },
          get isLoadingDocument() { throw "isLoadingDocument: Not Remoteable"; },

          receiveMessage: function(aMessage) {
            let args;
            let json = aMessage.json;
            switch (aMessage.name) {
              case "WebProgress:StateChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.stateFlags,
                  json.status
                ];

                this._notify(json.notifyFlags, "onStateChange", args);
                break;

              case "WebProgress:ProgressChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.curSelf,
                  json.maxSelf,
                  json.curTotal,
                  json.maxTotal
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_PROGRESS,
                             "onProgressChange",
                             args);
                break;

              case "WebProgress:LocationChange":
                let locationURI = this._browser._ios.newURI(json.location, null, null);
                this._browser._webNavigation._currentURI = locationURI;
                this._browser._webNavigation.canGoBack = json.canGoBack;
                this._browser._webNavigation.canGoForward = json.canGoForward;

                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  locationURI
                ];

                if (this._browser.contentWindowId != json.windowId) {
                  this._browser.contentWindowId = json.windowId;
                  this._browser._documentURI = json.documentURI;
                  this._browser._searchEngines = [];
                }

                this._browser._zoomLevel = 1;
                this._browser._updateCacheViewport();

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_LOCATION,
                             "onLocationChange",
                             args);

                break;

              case "WebProgress:StatusChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.status,
                  json.message
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_STATUS,
                             "onStatusChange",
                             args);
                break;

              case "WebProgress:SecurityChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.state
                ];

                this._browser._securityUI = {
                  SSLStatus: json.SSLStatus,
                  state: json.state
                }

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_SECURITY,
                             "onSecurityChange",
                             args);
                break;
            }
          },

          _notify: function(aFlags, aName, aArguments) {
            this._listeners.forEach(function(item) {
              if (item.flags & aFlags)
                item.listener[aName].apply(item.listener, aArguments);
            });
          }
        })
      ]]></field>

      <property name="contentWindow"
                readonly="true"
                onget="return null"/>

      <property name="sessionHistory"
                onget="throw 'sessionHistory: Not Remoteable'"
                readonly="true"/>

      <property name="markupDocumentViewer"
                onget="throw 'markupDocumentViewer: Not Remoteable'"
                readonly="true"/>

      <property name="contentViewerEdit"
                onget="throw 'contentViewerEdit: Not Remoteable'"
                readonly="true"/>

      <property name="contentViewerFile"
                onget="throw 'contentViewerFile: Not Remoteable'"
                readonly="true"/>

      <property name="documentCharsetInfo"
                onget="throw 'documentCharsetInfo: Not Remoteable'"
                readonly="true"/>

      <method name="scrollBy">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;

            let bcr = this.getBoundingClientRect();
            let viewportWidth = bcr.width;
            let viewportHeight = bcr.height;

            x = Math.floor(Math.max(0, Math.min(this._widthInDevicePx - viewportWidth, frameLoader.viewportScrollX + x)) - frameLoader.viewportScrollX);
            y = Math.floor(Math.max(0, Math.min(this._heightInDevicePx - viewportHeight, frameLoader.viewportScrollY + y)) - frameLoader.viewportScrollY);

            if (x == 0 && y == 0)
              return;

            frameLoader.scrollViewportBy(x, y);

            // Add this to the amount of pixels we have "used" from our cache. When this hits the
            // threshold, we will refresh.
            this._pendingPixelsX += x;
            this._pendingPixelsY += y;

            if (Math.abs(this._pendingPixelsX) >= this._pendingThresholdX ||
                Math.abs(this._pendingPixelsY) >= this._pendingThresholdY)
              this._updateCacheViewport();
          ]]>
        </body>
      </method>

      <method name="scrollTo">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            this.scrollBy(x - frameLoader.viewportScrollX, y - frameLoader.viewportScrollY);
          ]]>
        </body>
      </method>

      <method name="getPosition">
        <parameter name="scrollX"/>
        <parameter name="scrollY"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            scrollX.value = frameLoader.viewportScrollX;
            scrollY.value = frameLoader.viewportScrollY;
          ]]>
        </body>
      </method>
    </implementation>

  </binding>

</bindings>

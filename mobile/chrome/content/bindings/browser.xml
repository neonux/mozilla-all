<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - Peter Annema.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Peter Annema <disttsc@bart.nl> (Original Author of <browser>)
   -   Peter Parente <parente@cs.unc.edu>
   -   Christopher Thomas <cst@yecc.com>
   -   Michael Ventnor <m.ventnor@gmail.com>
   -   Arpad Borsos <arpad.borsos@googlemail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
  <!ENTITY % findBarDTD SYSTEM "chrome://global/locale/findbar.dtd" >
  %findBarDTD;
]>

<bindings id="remoteBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="local-browser" extends="chrome://global/content/bindings/browser.xml#browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <field name="_securityUI">null</field>
      <property name="securityUI">
        <getter><![CDATA[
          if (!this._securityUI) {
            const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
            if (!this.hasAttribute("disablesecurity") && SECUREBROWSERUI_CONTRACTID in Components.classes) {
              this.messageManager.sendAsyncMessage('SecurityUI:Init', { });
            }
          }

          return this._securityUI || {};
        ]]></getter>
        <setter><![CDATA[
          this._securityUI = val;
        ]]></setter>
      </property>

      <field name="_searchEngines">[]</field>
      <property name="searchEngines"
                onget="return this._searchEngines"
                readonly="true"/>

      <field name="_documentURI">null</field>
      <property name="documentURI"
                onget="return Services.io.newURI(this._documentURI, null, null)"
                readonly="true"/>

      <field name="contentWindowId">null</field>

      <property name="messageManager"
                onget="return this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.messageManager;"
                readonly="true"/>

      <field name="_contentTitle">null</field>

      <field name="_ios">
         Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
      </field>

      <field name="_messageListenerLocal"><![CDATA[
        ({
          self: this,
          receiveMessage: function receiveMessage(aMessage) {
            let self = this.self;
            let json = aMessage.json;

            switch (aMessage.name) {
              case "DOMPopupBlocked":
                self.onPopupBlocked(aMessage);
                break;

              case "pageshow":
                self.onPageShow(aMessage);

                if (self.mIconURL == "" && self._documentURI) {
                  // newURI call is throwing for chrome URI
                  try {
                    // Use documentURIObject in the favicon construction so that we
                    // do the right thing with about:-style error pages.  Bug 515188
                    let iconURI = Services.io.newURI(self.documentURI.prePath + "/favicon.ico", null, null);
                    if (!iconURI.schemeIs("javascript") && !gFaviconService.isFailedFavicon(iconURI)) {
                      gFaviconService.setAndLoadFaviconForPage(self.currentURI, iconURI, true);
                      self.mIconURL = iconURI.spec;
                    }
                  }
                  catch(e) {}
                }
                break;

              case "pagehide":
                self.onPageHide(aMessage);
                break;

              case "DOMTitleChanged":
                self._contentTitle = aMessage.json.title;
                break;

              case "DOMLinkAdded":
                let link = aMessage.json;
                // ignore results from subdocuments
                if (link.windowId != self.contentWindowId)
                  return;

                let linkType = self._getLinkType(link);
                switch(linkType) {
                  case "icon":
                    let iconURI = Services.io.newURI(link.href, link.charset, null);
                    if (!iconURI.schemeIs("javascript") && !gFaviconService.isFailedFavicon(iconURI)) {
                      gFaviconService.setAndLoadFaviconForPage(self.currentURI, iconURI, true);
                      self.mIconURL = iconURI.spec;
                    }
                    break;
                  case "search":
                    self._searchEngines.push({ title: link.title, href: link.href });
                    break;
                }
                break;

              case "MozScrolledAreaChanged":
                self._contentDocumentWidth = aMessage.json.width;
                self._contentDocumentHeight = aMessage.json.height;

                // Recalculate whether the visible area is actually in bounds
                self.scrollBy(0, 0);
                self._updateCacheViewport();
                break;
            }
          }
        })
      ]]></field>

      <method name="_getLinkType">
        <parameter name="aLink" />
        <body><![CDATA[
          let type = "";
          if (/\bicon\b/i(aLink.rel)) {
            type = "icon";
          }
          else if (/\bsearch\b/i(aLink.rel) && aLink.type && aLink.title) {
            let linkType = aLink.type.replace(/^\s+|\s*(?:;.*)?$/g, "").toLowerCase();
            if (linkType == "application/opensearchdescription+xml" && /^(?:https?|ftp):/i.test(aLink.href)) {
              type = "search";
            }
          }

          return type;
        ]]></body>
      </method>

      <field name="_webProgress"><![CDATA[
        ({
          _listeners: [],
          _browser: this,

          _init: function() {
            this._browser.messageManager.addMessageListener("WebProgress:StateChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:ProgressChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:LocationChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:StatusChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:SecurityChange", this);
          },

          addProgressListener: function(aListener, aNotifyFlags) {
            function hasFilter(item) {
              return item.listener == aListener;
            }

            if (this._listeners.some(hasFilter))
              return;

            this._listeners.push({
              listener: aListener,
              flags: aNotifyFlags
            });

            this._browser.messageManager.sendAsyncMessage("WebProgress:AddProgressListener", {
              notifyFlags: aNotifyFlags,
            });
          },

          removeProgressListener: function(aListener) {
            let self = this;
            function hasFilter(item) {
              if (item.listener == aListener)
                self._browser.messageManager.sendAsyncMessage("WebProgress:RemoveProgressListener", {
                  notifyFlags: item.flags,
                });
              return item.listener != aListener;
            }

            this._listeners = this._listeners.filter(hasFilter);
          },
          get DOMWindow() { throw "DOMWindow: Not Remoteable" },
          get isLoadingDocument() { throw "isLoadingDocument: Not Remoteable"; },

          receiveMessage: function(aMessage) {
            let args;
            let json = aMessage.json;
            switch (aMessage.name) {
              case "WebProgress:StateChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.stateFlags,
                  json.status
                ];

                this._notify(json.notifyFlags, "onStateChange", args);
                break;

              case "WebProgress:ProgressChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.curSelf,
                  json.maxSelf,
                  json.curTotal,
                  json.maxTotal
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_PROGRESS,
                             "onProgressChange",
                             args);
                break;

              case "WebProgress:LocationChange":
                let locationURI = this._browser._ios.newURI(json.location, null, null);

                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  locationURI
                ];

                if (this._browser.contentWindowId != json.windowId) {
                  this._browser.contentWindowId = json.windowId;
                  this._browser._documentURI = json.documentURI;
                  this._browser._searchEngines = [];
                }

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_LOCATION,
                             "onLocationChange",
                             args);

                break;

              case "WebProgress:StatusChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.status,
                  json.message
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_STATUS,
                             "onStatusChange",
                             args);
                break;

              case "WebProgress:SecurityChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.state
                ];

                this._browser._securityUI = {
                  SSLStatus: json.SSLStatus,
                  state: json.state
                }

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_SECURITY,
                             "onSecurityChange",
                             args);
                break;
            }
          },

          _notify: function(aFlags, aName, aArguments) {
            this._listeners.forEach(function(item) {
              if (item.flags & aFlags) {
                item.listener[aName].apply(item.listener, aArguments);
              }
            });
          }
        })
      ]]></field>

      <property name="webProgress"
                readonly="true"
                onget="return this._webProgress"/>

      <method name="onPageShow">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            this.attachFormFill();
            if (this.pageReport) {
              var json = aMessage.json;
              var i = 0;
              while (i < this.pageReport.length) {
                // Filter out irrelevant reports.
                if (this.pageReport[i].requestingWindowId == json.windowId)
                  i++;
                else
                  this.pageReport.splice(i, 1);
              }
              if (this.pageReport.length == 0) {
                this.pageReport = null;
                this.updatePageReport();
              }
            }
         ]]>
        </body>
      </method>

      <method name="onPageHide">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            if (this.pageReport) {
              this.pageReport = null;
              this.updatePageReport();
            }
            // Delete the feeds cache if we're hiding the topmost page
            // (as opposed to one of its iframes).
            if (this.feeds && aMessage.target == this)
              this.feeds = null;

            if (aMessage.windowId == this.contentWindowId)
              this.scale = 1;
         ]]>
        </body>
      </method>

      <method name="onPopupBlocked">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            if (!this.pageReport) {
              this.pageReport = [];
            }

            let json = aMessage.json;
            // XXX Replacing requestingWindow && requestingDocument affects
            // http://mxr.mozilla.org/mozilla-central/source/browser/base/content/browser.js#500
            var obj = {
              requestingWindowId: json.windowId,
              popupWindowURI: Services.io.newURI(json.popupWindowURI.spec, json.popupWindowURI.charset, null),
              popupWindowFeatures: json.popupWindowFeatures,
              popupWindowName: json.popupWindowName
            };

            this.pageReport.push(obj);
            this.pageReport.reported = false;
            this.updatePageReport();
          ]]>
        </body>
      </method>

      <field name="_frameLoader">null</field>

      <!-- Dimensions of content window -->
      <property name="contentWindowWidth"
                onget="return this._contentWindowWidth;"
                readonly="true"/>
      <property name="contentWindowHeight"
                onget="return this._contentWindowHeight;"
                readonly="true"/>

      <!-- Dimensions of content document -->
      <field name="_contentDocumentWidth">0</field>
      <field name="_contentDocumentHeight">0</field>
      <property name="contentDocumentWidth"
                onget="return this._contentDocumentWidth;"
                readonly="true"/>
      <property name="contentDocumentHeight"
                onget="return this._contentDocumentHeight;"
                readonly="true"/>

      <!-- Zoom level is the ratio of device pixels to CSS pixels -->
      <field name="_scale">1</field>
      <property name="scale"
                onget="return this._scale;"
                onset="return this._setScale(val);"/>

      <!-- These counters are used to update the cached viewport after they reach a certain
           threshold when scrolling -->
      <field name="_pendingPixelsX">0</field>
      <field name="_pendingPixelsY">0</field>
      <field name="_pendingThresholdX">0</field>
      <field name="_pendingThresholdY">0</field>
      <!-- This determines what percentage of cached pixels are not yet visible before the cache
           is refreshed. For instance, if we recached at 25% and there are originally a total of
           400px offscreen, we'd refresh once 100 of those pixels have been scrolled into
           view. -->
      <field name="_recacheRatio">1</field>

      <!-- The cache viewport is what parts of content is cached in the parent process for
           fast scrolling. This syncs that up with the current projection viewport. -->
      <method name="_updateCacheViewport">
        <body>
          <![CDATA[
            let cacheX = this._pendingThresholdX / this._recacheRatio;
            let cacheY = this._pendingThresholdY / this._recacheRatio;
            let bcr = this.getBoundingClientRect();

            let frameLoader = this._frameLoader;
            this.messageManager.sendAsyncMessage("Content:SetCacheViewport", {
              x: (frameLoader.viewportScrollX + bcr.width  / 2 - cacheX) / this._scale,
              y: (frameLoader.viewportScrollY + bcr.height / 2 - cacheY) / this._scale,
              w: (cacheX * 2) / this._scale,
              h: (cacheY * 2) / this._scale,
              scale: this._scale
            });

            this._pendingPixelsX = 0;
            this._pendingPixelsY = 0;
          ]]>
        </body>
      </method>

      <!-- Synchronize the CSS viewport with the projection viewport. -->
      <method name="_updateCSSViewport">
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            this.messageManager.sendAsyncMessage("Content:ScrollTo", {
              x: frameLoader.viewportScrollX / this._scale,
              y: frameLoader.viewportScrollY / this._scale
            });
          ]]>
        </body>
      </method>

      <!-- Sets the scale of CSS pixels to device pixels. Does not affect page layout. -->
      <method name="_setScale">
        <parameter name="scale"/>
        <body>
          <![CDATA[
            // XXX Not implemented for local browsers.
          ]]>
        </body>
      </method>

      <!-- Sets size of CSS viewport, which affects how page is layout. -->
      <method name="setWindowSize">
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
          <![CDATA[
            this._contentWindowWidth = width;
            this._contentWindowHeight = height;
            this.messageManager.sendAsyncMessage("Content:SetWindowSize", {
              width: width,
              height: height
            });
          ]]>
        </body>
      </method>

      <!-- Scroll viewport by (x, y) device pixels. -->
      <method name="scrollBy">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            this.contentWindow.scrollBy(x, y);
          ]]>
        </body>
      </method>

      <!-- Scroll viewport to (x, y) offset of document in device pixels. -->
      <method name="scrollTo">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            this.contentWindow.scrollTo(x, y);
          ]]>
        </body>
      </method>

      <!-- Get position of viewport in device pixels. -->
      <method name="getPosition">
        <body>
          <![CDATA[
            let scrollX = {}, scrollY = {};
            let cwu = this.contentWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).
                      getInterface(Components.interfaces.nsIDOMWindowUtils);
            cwu.getScrollXY(false, scrollX, scrollY);
            return { x: scrollX.value, y: scrollY.value };
          ]]>
        </body>
      </method>

      <constructor>
        <![CDATA[
          this._frameLoader = this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader;

          let prefService = Components.classes["@mozilla.org/preferences-service;1"]
                                              .getService(Components.interfaces.nsIPrefService)
                                              .QueryInterface(Components.interfaces.nsIPrefBranch2);

          this._recacheRatio = Math.max(.01, Math.min(1, prefService.getIntPref("toolkit.browser.recacheRatio") / 100));
          this._pendingThresholdX = Math.max(0, prefService.getIntPref("toolkit.browser.cachePixelX")) * this._recacheRatio;
          this._pendingThresholdY = Math.max(0, prefService.getIntPref("toolkit.browser.cachePixelY")) * this._recacheRatio;

          this.messageManager.loadFrameScript("chrome://browser/content/bindings/browser.js", true);
          this.messageManager.addMessageListener("DOMTitleChanged", this._messageListenerLocal);
          this.messageManager.addMessageListener("DOMLinkAdded", this._messageListenerLocal);
          this.messageManager.addMessageListener("pageshow", this._messageListenerLocal);
          this.messageManager.addMessageListener("pagehide", this._messageListenerLocal);
          this.messageManager.addMessageListener("DOMPopupBlocked", this._messageListenerLocal);
          this.messageManager.addMessageListener("MozScrolledAreaChanged", this._messageListenerLocal);

          this._webProgress._init();
        ]]>
      </constructor>

    </implementation>
  </binding>

  <binding id="remote-browser" extends="#local-browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <property name="accessibleType" readonly="true">
        <getter>
          <![CDATA[
            throw "accessibleType: Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="autoscrollEnabled">
        <getter>
          <![CDATA[
            throw "autoscrollEnabled: Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="docShell"
                onget="throw 'docShell: Not Remotable'"
                readonly="true"/>

      <field name="_contentTitle">null</field>

      <property name="contentTitle"
                onget="return this._contentTitle;"
                readonly="true"/>

      <field name="_webNavigation"><![CDATA[
        ({
          LOAD_FLAGS_MASK: 65535,
          LOAD_FLAGS_NONE: 0,
          LOAD_FLAGS_IS_REFRESH: 16,
          LOAD_FLAGS_IS_LINK: 32,
          LOAD_FLAGS_BYPASS_HISTORY: 64,
          LOAD_FLAGS_REPLACE_HISTORY: 128,
          LOAD_FLAGS_BYPASS_CACHE: 256,
          LOAD_FLAGS_BYPASS_PROXY: 512,
          LOAD_FLAGS_CHARSET_CHANGE: 1024,
          LOAD_FLAGS_STOP_CONTENT: 2048,
          LOAD_FLAGS_FROM_EXTERNAL: 4096,
          LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP: 8192,
          LOAD_FLAGS_FIRST_LOAD: 16384,
          LOAD_FLAGS_ALLOW_POPUPS: 32768,
          LOAD_FLAGS_BYPASS_CLASSIFIER: 65536,
          LOAD_FLAGS_FORCE_ALLOW_COOKIES: 131072,

          STOP_NETWORK: 1,
          STOP_CONTENT: 2,
          STOP_ALL: 3,

          canGoBack: false,
          canGoForward: false,
          goBack: function() { this._sendMessage("WebNavigation:GoBack", {}); },
          goForward: function() { this._sendMessage("WebNavigation:GoForward", {}); },
          gotoIndex: function(aIndex) { this._sendMessage("WebNavigation:GotoIndex", {index: aIndex}); },
          loadURI: function(aURI, aLoadFlags, aReferrer, aPostData, aHeaders) {
            try {
              this._currentURI = this._browser._ios.newURI(aURI, null, null);
            } catch(e) {}
            this._browser._contentTitle = "";
            this._sendMessage("WebNavigation:LoadURI", {uri: aURI, flags: aLoadFlags});
          },
          reload: function(aReloadFlags) { this._sendMessage("WebNavigation:Reload", {flags: aReloadFlags}); },
          stop: function(aStopFlags) { this._sendMessage("WebNavigation:Stop", {flags: aStopFlags}); },
          get document() { Components.utils.reportError("contentDocument is not available"); return null; },
          get currentURI() {
            if (!this._currentURI)
               this._currentURI = this._browser._ios.newURI("about:blank", null, null);

            return this._currentURI;
          },
          set currentURI(aURI) { this.loadURI(aURI.spec, null, null, null); },
          referringURI: null,
          get sessionHistory() { return null; },
          set sessionHistory(aValue) { },

          _currentURI: null,
          _browser: this,
          _sendMessage: function(aMessage, aData) {
            try {
              this._browser.messageManager.sendAsyncMessage(aMessage, aData);
            }
            catch (e) {
              Components.utils.reportError(e);
            }
         },

         QueryInterface: function(aIID) {
           if (aIID.equals(Components.interfaces.nsIWebNavigation) || aIID.equals(Components.interfaces.nsISupports))
             return this;
           throw Components.results.NS_NOINTERFACE;
         }
        })
      ]]></field>

      <property name="webNavigation"
                onget="return this._webNavigation;"
                readonly="true"/>

      <field name="_webProgress"><![CDATA[
        ({
          _listeners: [],
          _browser: this,

          _init: function() {
            this._browser.messageManager.addMessageListener("WebProgress:StateChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:ProgressChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:LocationChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:StatusChange", this);
            this._browser.messageManager.addMessageListener("WebProgress:SecurityChange", this);
          },

          addProgressListener: function(aListener, aNotifyFlags) {
            function hasFilter(item) {
              return item.listener == aListener;
            }

            if (this._listeners.some(hasFilter))
              return;

            this._listeners.push({
              listener: aListener,
              flags: aNotifyFlags
            });
          },

          removeProgressListener: function(aListener) {
            function hasFilter(item) {
              return item.listener != aListener;
            }

            this._listeners = this._listeners.filter(hasFilter);
          },
          get DOMWindow() { throw "DOMWindow: Not Remoteable" },
          get isLoadingDocument() { throw "isLoadingDocument: Not Remoteable"; },

          receiveMessage: function(aMessage) {
            let args;
            let json = aMessage.json;
            switch (aMessage.name) {
              case "WebProgress:StateChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.stateFlags,
                  json.status
                ];

                this._notify(json.notifyFlags, "onStateChange", args);
                break;

              case "WebProgress:ProgressChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.curSelf,
                  json.maxSelf,
                  json.curTotal,
                  json.maxTotal
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_PROGRESS,
                             "onProgressChange",
                             args);
                break;

              case "WebProgress:LocationChange":
                let locationURI = this._browser._ios.newURI(json.location, null, null);
                this._browser._webNavigation._currentURI = locationURI;
                this._browser._webNavigation.canGoBack = json.canGoBack;
                this._browser._webNavigation.canGoForward = json.canGoForward;

                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  locationURI
                ];

                if (this._browser.contentWindowId != json.windowId) {
                  this._browser.contentWindowId = json.windowId;
                  this._browser._documentURI = json.documentURI;
                  this._browser._searchEngines = [];
                }

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_LOCATION,
                             "onLocationChange",
                             args);

                break;

              case "WebProgress:StatusChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.status,
                  json.message
                ];
                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_STATUS,
                             "onStatusChange",
                             args);
                break;

              case "WebProgress:SecurityChange":
                args = [
                  { windowId: json.windowId, browser: this._browser },
                  {},
                  json.state
                ];

                this._browser._securityUI = {
                  SSLStatus: json.SSLStatus,
                  state: json.state
                }

                this._notify(Components.interfaces.nsIWebProgress.NOTIFY_SECURITY,
                             "onSecurityChange",
                             args);
                break;
            }
          },

          _notify: function(aFlags, aName, aArguments) {
            this._listeners.forEach(function(item) {
              if (item.flags & aFlags)
                item.listener[aName].apply(item.listener, aArguments);
            });
          }
        })
      ]]></field>

      <property name="contentWindow"
                readonly="true"
                onget="return null"/>

      <property name="sessionHistory"
                onget="throw 'sessionHistory: Not Remoteable'"
                readonly="true"/>

      <property name="markupDocumentViewer"
                onget="throw 'markupDocumentViewer: Not Remoteable'"
                readonly="true"/>

      <property name="contentViewerEdit"
                onget="throw 'contentViewerEdit: Not Remoteable'"
                readonly="true"/>

      <property name="contentViewerFile"
                onget="throw 'contentViewerFile: Not Remoteable'"
                readonly="true"/>

      <property name="documentCharsetInfo"
                onget="throw 'documentCharsetInfo: Not Remoteable'"
                readonly="true"/>

      <constructor>
        <![CDATA[
          this.messageManager.addMessageListener("scroll", this._messageListenerRemote);
        ]]>
      </constructor>

      <field name="_messageListenerRemote"><![CDATA[
        ({
          self: this,
          receiveMessage: function receiveMessage(aMessage) {
            let self = this.self;
            let json = aMessage.json;

            switch (aMessage.name) {
              case "scroll":
                // When CSS scroll offset changes, we must redefine our cache viewport because
                // the cache viewport coordinate system's origin is the CSS scroll offset. Setting
                // _pendingPixels* guarantees that _updateCacheViewport is called in scrollTo.
                self._pendingPixelsX = Number.MAX_VALUE;
                self._pendingPixelsY = Number.MAX_VALUE;

                // Use floor so that we always guarantee top-left corner of content is visible.
                self.scrollTo(Math.floor(json.x * self.scale), Math.floor(json.y * self.scale));
                break;
           }
         }
       })
      ]]></field>

      <!-- Sets the scale of CSS pixels to device pixels. Does not affect page layout. -->
      <method name="_setScale">
        <parameter name="scale"/>
        <body>
          <![CDATA[
            if (scale <= 0) throw "Bad scale given.";

            this._scale = scale;
            this._frameLoader.setViewportScale(scale, scale);
            this._updateCacheViewport();

            let event = document.createEvent("Events");
            event.initEvent("ZoomChanged", true, false);
            this.dispatchEvent(event);
          ]]>
        </body>
      </method>

      <!-- Scroll by (x, y) device pixels -->
      <method name="scrollBy">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;

            // Bounding content rectangle is in device pixels
            let bcr = this.getBoundingClientRect();
            let viewportWidth = bcr.width;
            let viewportHeight = bcr.height;
            // Calculate document dimensions in device pixels
            let docWidth = this.contentDocumentWidth * this.scale;
            let docHeight = this.contentDocumentHeight * this.scale;

            x = Math.floor(Math.max(0, Math.min(docWidth - viewportWidth, frameLoader.viewportScrollX + x)) - frameLoader.viewportScrollX);
            y = Math.floor(Math.max(0, Math.min(docHeight - viewportHeight, frameLoader.viewportScrollY + y)) - frameLoader.viewportScrollY);

            if (x == 0 && y == 0)
              return;

            frameLoader.scrollViewportBy(x, y);

            // Add this to the amount of pixels we have "used" from our cache. When this hits the
            // threshold, we will refresh.
            this._pendingPixelsX += x;
            this._pendingPixelsY += y;

            if (Math.abs(this._pendingPixelsX) > Math.max(0, this._pendingThresholdX - bcr.width / 2) ||
                Math.abs(this._pendingPixelsY) > Math.max(0, this._pendingThresholdY - bcr.height / 2))
              this._updateCacheViewport();
          ]]>
        </body>
      </method>

      <!-- Scroll to position (x, y) in device pixels -->
      <method name="scrollTo">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            this.scrollBy(x - frameLoader.viewportScrollX, y - frameLoader.viewportScrollY);
          ]]>
        </body>
      </method>

      <!-- Get position of window in device pixels -->
      <method name="getPosition">
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            return { x: frameLoader.viewportScrollX, y: frameLoader.viewportScrollY };
          ]]>
        </body>
      </method>
    </implementation>

  </binding>

</bindings>

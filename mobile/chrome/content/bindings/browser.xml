<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - Peter Annema.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Peter Annema <disttsc@bart.nl> (Original Author of <browser>)
   -   Peter Parente <parente@cs.unc.edu>
   -   Christopher Thomas <cst@yecc.com>
   -   Michael Ventnor <m.ventnor@gmail.com>
   -   Arpad Borsos <arpad.borsos@googlemail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
  <!ENTITY % findBarDTD SYSTEM "chrome://global/locale/findbar.dtd" >
  %findBarDTD;
]>

<bindings id="remoteBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="local-browser" extends="chrome://global/content/bindings/browser.xml#browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <field name="_securityUI">null</field>
      <property name="securityUI">
        <getter><![CDATA[
          return this._securityUI || {};
        ]]></getter>
        <setter><![CDATA[
          this._securityUI = val;
        ]]></setter>
      </property>

      <field name="_searchEngines">[]</field>
      <property name="searchEngines"
                onget="return this._searchEngines"
                readonly="true"/>

      <field name="_documentURI">null</field>
      <property name="documentURI"
                onget="return this._documentURI ? Services.io.newURI(this._documentURI, null, null) : null"
                readonly="true"/>

      <field name="contentWindowId">null</field>

      <property name="messageManager"
                onget="return this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.messageManager;"
                readonly="true"/>

      <field name="_contentTitle">null</field>

      <field name="_ios">
         Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
      </field>

      <field name="_messageListenerLocal"><![CDATA[
        ({
          self: this,
          receiveMessage: function receiveMessage(aMessage) {
            let self = this.self;
            let json = aMessage.json;

            switch (aMessage.name) {
              case "DOMPopupBlocked":
                self.onPopupBlocked(aMessage);
                break;

              case "pageshow":
                self.onPageShow(aMessage);

                if (self.mIconURL == "" && self._documentURI) {
                  // newURI call is throwing for chrome URI
                  try {
                    // Use documentURIObject in the favicon construction so that we
                    // do the right thing with about:-style error pages.  Bug 515188
                    self.loadFavicon(self.documentURI.prePath + "/favicon.ico", null);
                  }
                  catch(e) {}
                }
                break;

              case "pagehide":
                self.onPageHide(aMessage);
                break;

              case "DOMTitleChanged":
                self._contentTitle = aMessage.json.title;
                break;

              case "DOMLinkAdded":
                let link = aMessage.json;
                // ignore results from subdocuments
                if (link.windowId != self.contentWindowId)
                  return;

                let linkType = self._getLinkType(link);
                switch(linkType) {
                  case "icon":
                    self.loadFavicon(link.href, link.charset);
                    break;
                  case "search":
                    self._searchEngines.push({ title: link.title, href: link.href });
                    break;
                }
                break;

              case "MozScrolledAreaChanged":
                self._contentDocumentWidth = aMessage.json.width;
                self._contentDocumentHeight = aMessage.json.height;

                // Recalculate whether the visible area is actually in bounds
                self.scrollBy(0, 0);
                self._updateCacheViewport();
                break;
            }
          }
        })
      ]]></field>

      <method name="loadFavicon">
        <parameter name="aURL"/>
        <parameter name="aCharset"/>
        <body><![CDATA[
            let iconURI = Services.io.newURI(aURL, aCharset, null);
            if (this.shouldLoadFavicon(iconURI)) {
              gFaviconService.setAndLoadFaviconForPage(this.currentURI, iconURI, true);
              this.mIconURL = iconURI.spec;
            }
            else {
               this.mIconURL = "";
            }
        ]]></body>
      </method>

      <method name="shouldLoadFavicon">
        <parameter name="aURI"/>
        <body><![CDATA[
          let docURI = this.currentURI;
          return (!gFaviconService.isFailedFavicon(aURI) && docURI && ("schemeIs" in docURI) &&
                  (docURI.schemeIs("http") || docURI.schemeIs("https") || docURI.schemeIs("about") || docURI.schemeIs("chrome")));
        ]]></body>
      </method>

      <method name="_getLinkType">
        <parameter name="aLink" />
        <body><![CDATA[
          let type = "";
          if (/\bicon\b/i(aLink.rel)) {
            type = "icon";
          }
          else if (/\bsearch\b/i(aLink.rel) && aLink.type && aLink.title) {
            let linkType = aLink.type.replace(/^\s+|\s*(?:;.*)?$/g, "").toLowerCase();
            if (linkType == "application/opensearchdescription+xml" && /^(?:https?|ftp):/i.test(aLink.href)) {
              type = "search";
            }
          }

          return type;
        ]]></body>
      </method>

      <field name="_webProgress"><![CDATA[
        ({
          _browser: this,

          _init: function() {
            this._browser.messageManager.addMessageListener("Content:StateChange", this);
            this._browser.messageManager.addMessageListener("Content:LocationChange", this);
            this._browser.messageManager.addMessageListener("Content:SecurityChange", this);
          },

          receiveMessage: function(aMessage) {
            let json = aMessage.json;
            switch (aMessage.name) {
              case "Content:StateChange":
                this._browser.updateWindowId(json.contentWindowId);
                break;

              case "Content:LocationChange":
                try {
                  let locationURI = this._browser._ios.newURI(json.location, null, null);
                  this._browser._webNavigation._currentURI = locationURI;
                  this._browser._webNavigation.canGoBack = json.canGoBack;
                  this._browser._webNavigation.canGoForward = json.canGoForward;
                } catch(e) {}

                if (this._browser.updateWindowId(json.contentWindowId)) {
                  this._browser._documentURI = json.documentURI;
                  this._browser._searchEngines = [];
                }
                break;

              case "Content:SecurityChange":
                let serhelper = Cc["@mozilla.org/network/serialization-helper;1"].getService(Ci.nsISerializationHelper);
                let SSLStatus = json.SSLStatusAsString ? serhelper.deserializeObject(json.SSLStatusAsString) : null;
                if (SSLStatus) {
                  SSLStatus.QueryInterface(Ci.nsISSLStatus);
                  if (SSLStatus) {
                    // We must check the Extended Validation (EV) state here, on the chrome
                    // process, because NSS is needed for that determination.
                    let ii = SSLStatus.serverCert.QueryInterface(Ci.nsIIdentityInfo);
                    if (ii && ii.isExtendedValidation)
                      json.state |= Ci.nsIWebProgressListener.STATE_IDENTITY_EV_TOPLEVEL;
                  }
                }

                let data = this._getIdentityData(SSLStatus);
                this._browser._securityUI = {
                  SSLStatus: SSLStatus ? {serverCert: data} : null,
                  state: json.state
                }
                this._browser.updateWindowId(json.contentWindowId);
                break;
            }
          },

          /**
           * Helper to parse out the important parts of the SSL cert for use in constructing
           * identity UI strings
           */
          _getIdentityData: function(status) {
            let result = {};

            if (status) {
              let cert = status.serverCert;

              // Human readable name of Subject
              result.subjectOrg = cert.organization;

              // SubjectName fields, broken up for individual access
              if (cert.subjectName) {
                result.subjectNameFields = {};
                cert.subjectName.split(",").forEach(function(v) {
                  var field = v.split("=");
                  if (field[1])
                    this[field[0]] = field[1];
                }, result.subjectNameFields);

                // Call out city, state, and country specifically
                result.city = result.subjectNameFields.L;
                result.state = result.subjectNameFields.ST;
                result.country = result.subjectNameFields.C;
              }

              // Human readable name of Certificate Authority
              result.caOrg =  cert.issuerOrganization || cert.issuerCommonName;

              if (!this._overrideService)
                this._overrideService = Cc["@mozilla.org/security/certoverride;1"].getService(Ci.nsICertOverrideService);

              // Check whether this site is a security exception.
              let currentURI = this._browser._webNavigation._currentURI;
              result.isException = !!this._overrideService.hasMatchingOverride(currentURI.asciiHost, currentURI.port, cert, {}, {});
            }

            return result;
          }
        })
      ]]></field>

      <property name="webProgress"
                readonly="true"
                onget="return null"/>

      <method name="onPageShow">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            this.attachFormFill();
            if (this.pageReport) {
              var json = aMessage.json;
              var i = 0;
              while (i < this.pageReport.length) {
                // Filter out irrelevant reports.
                if (this.pageReport[i].requestingWindowId == json.windowId)
                  i++;
                else
                  this.pageReport.splice(i, 1);
              }
              if (this.pageReport.length == 0) {
                this.pageReport = null;
                this.updatePageReport();
              }
            }
         ]]>
        </body>
      </method>

      <method name="onPageHide">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            if (this.pageReport) {
              this.pageReport = null;
              this.updatePageReport();
            }
            // Delete the feeds cache if we're hiding the topmost page
            // (as opposed to one of its iframes).
            if (this.feeds && aMessage.target == this)
              this.feeds = null;

            if (aMessage.windowId == this.contentWindowId)
              this.scale = 1;
         ]]>
        </body>
      </method>

      <method name="onPopupBlocked">
        <parameter name="aMessage"/>
        <body>
          <![CDATA[
            if (!this.pageReport) {
              this.pageReport = [];
            }

            let json = aMessage.json;
            // XXX Replacing requestingWindow && requestingDocument affects
            // http://mxr.mozilla.org/mozilla-central/source/browser/base/content/browser.js#500
            var obj = {
              requestingWindowId: json.windowId,
              popupWindowURI: Services.io.newURI(json.popupWindowURI.spec, json.popupWindowURI.charset, null),
              popupWindowFeatures: json.popupWindowFeatures,
              popupWindowName: json.popupWindowName
            };

            this.pageReport.push(obj);
            this.pageReport.reported = false;
            this.updatePageReport();
          ]]>
        </body>
      </method>

      <field name="_frameLoader">null</field>

      <!-- Dimensions of content window -->
      <property name="contentWindowWidth"
                onget="return this._contentWindowWidth;"
                readonly="true"/>
      <property name="contentWindowHeight"
                onget="return this._contentWindowHeight;"
                readonly="true"/>

      <!-- Dimensions of content document -->
      <field name="_contentDocumentWidth">0</field>
      <field name="_contentDocumentHeight">0</field>
      <property name="contentDocumentWidth"
                onget="return this._contentDocumentWidth;"
                readonly="true"/>
      <property name="contentDocumentHeight"
                onget="return this._contentDocumentHeight;"
                readonly="true"/>

      <!-- Zoom level is the ratio of device pixels to CSS pixels -->
      <field name="_scale">1</field>
      <property name="scale"
                onget="return this._scale;"
                onset="return this._setScale(val);"/>

      <!-- These counters are used to update the cached viewport after they reach a certain
           threshold when scrolling -->
      <field name="_pendingPixelsX">0</field>
      <field name="_pendingPixelsY">0</field>
      <field name="_pendingThresholdX">0</field>
      <field name="_pendingThresholdY">0</field>
      <!-- This determines what percentage of cached pixels are not yet visible before the cache
           is refreshed. For instance, if we recached at 25% and there are originally a total of
           400px offscreen, we'd refresh once 100 of those pixels have been scrolled into
           view. -->
      <field name="_recacheRatio">1</field>

      <!-- The cache viewport is what parts of content is cached in the parent process for
           fast scrolling. This syncs that up with the current projection viewport. -->
      <method name="_updateCacheViewport">
        <body>
          <![CDATA[
            let scale = this._scale;
            let bcr = this.getBoundingClientRect();

            let cacheX = Math.max(this._pendingThresholdX / this._recacheRatio, bcr.width / 2);
            let cacheY = Math.max(this._pendingThresholdY / this._recacheRatio, bcr.height / 2);

            let frameLoader = this._frameLoader;
            this.messageManager.sendAsyncMessage("Content:SetCacheViewport", {
              x: (frameLoader.viewportScrollX - cacheX + bcr.width  / 2) / scale,
              y: (frameLoader.viewportScrollY - cacheY + bcr.height / 2) / scale,
              w: cacheX * 2 / scale,
              h: cacheY * 2 / scale,
              scale: scale
            });

            this._pendingPixelsX = 0;
            this._pendingPixelsY = 0;
          ]]>
        </body>
      </method>

      <!-- Synchronize the CSS viewport with the projection viewport. -->
      <method name="_updateCSSViewport">
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            this.messageManager.sendAsyncMessage("Content:ScrollTo", {
              x: frameLoader.viewportScrollX / this._scale,
              y: frameLoader.viewportScrollY / this._scale
            });
          ]]>
        </body>
      </method>

      <!-- Sets the scale of CSS pixels to device pixels. Does not affect page layout. -->
      <method name="_setScale">
        <parameter name="scale"/>
        <body>
          <![CDATA[
            // XXX Not implemented for local browsers.
          ]]>
        </body>
      </method>

      <!-- Sets size of CSS viewport, which affects how page is layout. -->
      <method name="setWindowSize">
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
          <![CDATA[
            this._contentWindowWidth = width;
            this._contentWindowHeight = height;
            this.messageManager.sendAsyncMessage("Content:SetWindowSize", {
              width: width,
              height: height
            });
          ]]>
        </body>
      </method>

      <!-- Scroll viewport by (x, y) device pixels. -->
      <method name="scrollBy">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let position = this.getPosition();
            x = Math.floor(Math.max(0, Math.min(this.contentDocumentWidth,  position.x+x))-position.x);
            y = Math.floor(Math.max(0, Math.min(this.contentDocumentHeight, position.y+y))-position.y);
            this.contentWindow.scrollBy(x, y);
          ]]>
        </body>
      </method>

      <!-- Scroll viewport to (x, y) offset of document in device pixels. -->
      <method name="scrollTo">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            x = Math.floor(Math.max(0, Math.min(this.contentDocumentWidth,  x)));
            y = Math.floor(Math.max(0, Math.min(this.contentDocumentHeight, y)));
            this.contentWindow.scrollTo(x, y);
          ]]>
        </body>
      </method>

      <!-- Get position of viewport in device pixels. -->
      <method name="getPosition">
        <body>
          <![CDATA[
            let scrollX = {}, scrollY = {};
            let cwu = this.contentWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).
                      getInterface(Components.interfaces.nsIDOMWindowUtils);
            cwu.getScrollXY(false, scrollX, scrollY);
            return { x: scrollX.value, y: scrollY.value };
          ]]>
        </body>
      </method>

      <!-- Change client coordinates in device pixels to page-relative ones in CSS px. -->
      <method name="transformClientToBrowser">
        <parameter name="clientX"/>
        <parameter name="clientY"/>
        <body>
          <![CDATA[
            let bcr = this.getBoundingClientRect();
            let scroll = this.getPosition();
            return { x: (clientX + scroll.x - bcr.left) / this._scale,
                     y: (clientY + scroll.y - bcr.top) / this._scale };
          ]]>
        </body>
      </method>

      <constructor>
        <![CDATA[
          this._frameLoader = this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader;

          let prefService = Components.classes["@mozilla.org/preferences-service;1"]
                                              .getService(Components.interfaces.nsIPrefService)
                                              .QueryInterface(Components.interfaces.nsIPrefBranch2);

          this._recacheRatio = Math.max(.01, Math.min(1, prefService.getIntPref("toolkit.browser.recacheRatio") / 100));
          this._pendingThresholdX = Math.max(0, prefService.getIntPref("toolkit.browser.cachePixelX")) * this._recacheRatio;
          this._pendingThresholdY = Math.max(0, prefService.getIntPref("toolkit.browser.cachePixelY")) * this._recacheRatio;

          this.messageManager.loadFrameScript("chrome://browser/content/bindings/browser.js", true);
          this.messageManager.addMessageListener("DOMTitleChanged", this._messageListenerLocal);
          this.messageManager.addMessageListener("DOMLinkAdded", this._messageListenerLocal);
          this.messageManager.addMessageListener("pageshow", this._messageListenerLocal);
          this.messageManager.addMessageListener("pagehide", this._messageListenerLocal);
          this.messageManager.addMessageListener("DOMPopupBlocked", this._messageListenerLocal);
          this.messageManager.addMessageListener("MozScrolledAreaChanged", this._messageListenerLocal);

          this._webProgress._init();
        ]]>
      </constructor>

      <method name="updateWindowId">
         <parameter name="aNewId"/>
         <body><![CDATA[
            if (this.contentWindowId != aNewId) {
               this.contentWindowId = aNewId;
               return true;
            }
            return false;
         ]]></body>
      </method>

      <field name="_active">false</field>
      <property name="active" onget="return this._active;">
         <setter>
            this._active = val;
            this.messageManager.sendAsyncMessage((val ? "Content:Activate" : "Content:Deactivate"), {});
            if (val)
              this._updateCacheViewport();
         </setter>
      </property>

    </implementation>
  </binding>

  <binding id="remote-browser" extends="#local-browser">
    <implementation type="application/javascript" implements="nsIAccessibleProvider, nsIObserver, nsIDOMEventListener, nsIFrameMessageListener">
      <property name="accessibleType" readonly="true">
        <getter>
          <![CDATA[
            throw "accessibleType: Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="autoscrollEnabled">
        <getter>
          <![CDATA[
            throw "autoscrollEnabled: Supports Remote?";
          ]]>
        </getter>
      </property>

      <property name="docShell"
                onget="return null"
                readonly="true"/>

      <field name="_contentTitle">null</field>

      <property name="contentTitle"
                onget="return this._contentTitle;"
                readonly="true"/>

      <field name="_webNavigation"><![CDATA[
        ({
          LOAD_FLAGS_MASK: 65535,
          LOAD_FLAGS_NONE: 0,
          LOAD_FLAGS_IS_REFRESH: 16,
          LOAD_FLAGS_IS_LINK: 32,
          LOAD_FLAGS_BYPASS_HISTORY: 64,
          LOAD_FLAGS_REPLACE_HISTORY: 128,
          LOAD_FLAGS_BYPASS_CACHE: 256,
          LOAD_FLAGS_BYPASS_PROXY: 512,
          LOAD_FLAGS_CHARSET_CHANGE: 1024,
          LOAD_FLAGS_STOP_CONTENT: 2048,
          LOAD_FLAGS_FROM_EXTERNAL: 4096,
          LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP: 8192,
          LOAD_FLAGS_FIRST_LOAD: 16384,
          LOAD_FLAGS_ALLOW_POPUPS: 32768,
          LOAD_FLAGS_BYPASS_CLASSIFIER: 65536,
          LOAD_FLAGS_FORCE_ALLOW_COOKIES: 131072,

          STOP_NETWORK: 1,
          STOP_CONTENT: 2,
          STOP_ALL: 3,

          canGoBack: false,
          canGoForward: false,
          goBack: function() { this._sendMessage("WebNavigation:GoBack", {}); },
          goForward: function() { this._sendMessage("WebNavigation:GoForward", {}); },
          gotoIndex: function(aIndex) { this._sendMessage("WebNavigation:GotoIndex", {index: aIndex}); },
          loadURI: function(aURI, aLoadFlags, aReferrer, aPostData, aHeaders) {
            this._browser.userTypedValue = aURI;
            this._browser._contentTitle = "";
            this._sendMessage("WebNavigation:LoadURI", {uri: aURI, flags: aLoadFlags});
          },
          reload: function(aReloadFlags) { this._sendMessage("WebNavigation:Reload", {flags: aReloadFlags}); },
          stop: function(aStopFlags) { this._sendMessage("WebNavigation:Stop", {flags: aStopFlags}); },
          get document() { Components.utils.reportError("contentDocument is not available"); return null; },
          get currentURI() {
            if (!this._currentURI)
               this._currentURI = this._browser._ios.newURI("about:blank", null, null);

            return this._currentURI;
          },
          set currentURI(aURI) { this.loadURI(aURI.spec, null, null, null); },
          referringURI: null,
          get sessionHistory() { return null; },
          set sessionHistory(aValue) { },

          _currentURI: null,
          _browser: this,
          _sendMessage: function(aMessage, aData) {
            try {
              this._browser.messageManager.sendAsyncMessage(aMessage, aData);
            }
            catch (e) {
              Components.utils.reportError(e);
            }
         },

         QueryInterface: function(aIID) {
           if (aIID.equals(Components.interfaces.nsIWebNavigation) || aIID.equals(Components.interfaces.nsISupports))
             return this;
           throw Components.results.NS_NOINTERFACE;
         }
        })
      ]]></field>

      <property name="webNavigation"
                onget="return this._webNavigation;"
                readonly="true"/>

      <property name="contentWindow"
                readonly="true"
                onget="return null"/>

      <property name="sessionHistory"
                onget="return null"
                readonly="true"/>

      <property name="markupDocumentViewer"
                onget="return null"
                readonly="true"/>

      <property name="contentViewerEdit"
                onget="return null"
                readonly="true"/>

      <property name="contentViewerFile"
                onget="return null"
                readonly="true"/>

      <property name="documentCharsetInfo"
                onget="return null"
                readonly="true"/>

      <constructor>
        <![CDATA[
          this.messageManager.addMessageListener("scroll", this._messageListenerRemote);
        ]]>
      </constructor>

      <field name="scrollSync">true</field>

      <field name="_messageListenerRemote"><![CDATA[
        ({
          self: this,
          receiveMessage: function receiveMessage(aMessage) {
            let self = this.self;
            let json = aMessage.json;

            switch (aMessage.name) {
              case "scroll":
                if (!self.scrollSync)
                  return;

                // When CSS scroll offset changes, we must redefine our cache viewport because
                // the cache viewport coordinate system's origin is the CSS scroll offset. Setting
                // _pendingPixels* guarantees that _updateCacheViewport is called in scrollTo.
                self._pendingPixelsX = Number.MAX_VALUE;
                self._pendingPixelsY = Number.MAX_VALUE;

                // Use floor so that we always guarantee top-left corner of content is visible.
                self.scrollTo(Math.floor(json.x * self.scale), Math.floor(json.y * self.scale));
                break;
           }
         }
       })
      ]]></field>

      <!-- Sets the scale of CSS pixels to device pixels. Does not affect page layout. -->
      <method name="_setScale">
        <parameter name="scale"/>
        <body>
          <![CDATA[
            if (scale <= 0 || scale == this._scale)
              return;

            this._scale = scale;
            this._frameLoader.setViewportScale(scale, scale);
            this._updateCacheViewport();

            let event = document.createEvent("Events");
            event.initEvent("ZoomChanged", true, false);
            this.dispatchEvent(event);
          ]]>
        </body>
      </method>

      <!-- Scroll by (x, y) device pixels -->
      <method name="scrollBy">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;

            // Bounding content rectangle is in device pixels
            let bcr = this.getBoundingClientRect();
            let viewportWidth = bcr.width;
            let viewportHeight = bcr.height;
            // Calculate document dimensions in device pixels
            let docWidth = this.contentDocumentWidth * this.scale;
            let docHeight = this.contentDocumentHeight * this.scale;

            x = Math.floor(Math.max(0, Math.min(docWidth - viewportWidth, frameLoader.viewportScrollX + x)) - frameLoader.viewportScrollX);
            y = Math.floor(Math.max(0, Math.min(docHeight - viewportHeight, frameLoader.viewportScrollY + y)) - frameLoader.viewportScrollY);

            if (x == 0 && y == 0)
              return;

            frameLoader.scrollViewportBy(x, y);

            // Add this to the amount of pixels we have "used" from our cache. When this hits the
            // threshold, we will refresh.
            this._pendingPixelsX += x;
            this._pendingPixelsY += y;

            if (Math.abs(this._pendingPixelsX) > Math.max(0, this._pendingThresholdX - bcr.width / 2) ||
                Math.abs(this._pendingPixelsY) > Math.max(0, this._pendingThresholdY - bcr.height / 2))
              this._updateCacheViewport();
          ]]>
        </body>
      </method>

      <!-- Scroll to position (x, y) in device pixels -->
      <method name="scrollTo">
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            this.scrollBy(x - frameLoader.viewportScrollX, y - frameLoader.viewportScrollY);
          ]]>
        </body>
      </method>

      <!-- Get position of window in device pixels -->
      <method name="getPosition">
        <body>
          <![CDATA[
            let frameLoader = this._frameLoader;
            return { x: frameLoader.viewportScrollX, y: frameLoader.viewportScrollY };
          ]]>
        </body>
      </method>
    </implementation>

  </binding>

</bindings>

diff --git a/include/oggplay/oggplay.h b/include/oggplay/oggplay.h
index 019958a..cdcb168 100644
--- a/include/oggplay/oggplay.h
+++ b/include/oggplay/oggplay.h
@@ -56,20 +56,27 @@ typedef int (OggPlayDataCallback)(OggPlay *player, int num_records,
 #include <oggplay/oggplay_callback_info.h>
 #include <oggplay/oggplay_tools.h>
 #include <oggplay/oggplay_seek.h>
-/*
-#include <oggplay/oggplay_retrieve.h>
-#include <oggplay/oggplay_cmml.h>
-*/
-
-OggPlay *
-oggplay_init(void);
-
-OggPlayErrorCode
-oggplay_set_reader(OggPlay *OS, OggPlayReader *OSR);
 
+/**
+ * Create an OggPlay handle associated with the given reader.
+ * The functions creates a new OggPlay handle and associates with
+ * the given OggPlayReader and initialises the buffer.
+ * 
+ *
+ * @param reader an OggPlayReader handle associated with the Ogg content
+ * @return A new OggPlay handle
+ * @retval NULL in case of error.
+ */
 OggPlay *
 oggplay_open_with_reader(OggPlayReader *reader);
 
+/**
+ * Create a new OggPlay handle associated with the given reader.
+ *
+ * \param reader OggPlayReader handle associated with the Ogg content
+ * \return A new OggPlay handle
+ * \retval NULL in case of error.
+ */
 OggPlay *
 oggplay_new_with_reader(OggPlayReader *reader);
 
@@ -128,6 +135,13 @@ oggplay_buffer_release(OggPlay *player, OggPlayCallbackInfo **track_info);
 void
 oggplay_prepare_for_close(OggPlay *me);
 
+/**
+ * @brief Destroys the OggPlay handle along with the associated OggPlayReader
+ * and clears out the buffer and shuts down the callback function. 
+ *
+ * @param player an OggPlay handle
+ * @retval E_OGGPLAY_OK on success 
+ */
 OggPlayErrorCode
 oggplay_close(OggPlay *player);
 
diff --git a/include/oggplay/oggplay_enums.h b/include/oggplay/oggplay_enums.h
index cda068f..6f4790f 100644
--- a/include/oggplay/oggplay_enums.h
+++ b/include/oggplay/oggplay_enums.h
@@ -62,6 +62,7 @@ typedef enum OggPlayErrorCode {
   E_OGGPLAY_TIMEOUT           = -17,
   E_OGGPLAY_CANT_SEEK         = -18,
   E_OGGPLAY_NO_KATE_SUPPORT   = -19,
+  E_OGGPLAY_OUT_OF_MEMORY     = -20,
   E_OGGPLAY_NOTCHICKENPAYBACK = -777
 } OggPlayErrorCode;
 
diff --git a/include/oggplay/oggplay_reader.h b/include/oggplay/oggplay_reader.h
index 992f416..21b5206 100644
--- a/include/oggplay/oggplay_reader.h
+++ b/include/oggplay/oggplay_reader.h
@@ -63,9 +63,25 @@ typedef struct _OggPlayReader {
   long              (*io_tell)(void *user_handle);
 } OggPlayReader;
 
+/**
+ * Create and initialise an OggPlayReader for a given Ogg file.
+ * 
+ * @param filename The file to open
+ * @return A new OggPlayReader handle
+ * @retval NULL on error.
+ */
 OggPlayReader *
 oggplay_file_reader_new(char *filename);
 
+/**
+ * Create and initialise an OggPlayReader for an Ogg content at a given URI. 
+ *
+ * @param uri The URI to the Ogg file.
+ * @param proxy Proxy 
+ * @param proxy_port Proxy port.
+ * @return A new OggPlayReader handle
+ * @retval NULL on error.
+ */
 OggPlayReader *
 oggplay_tcp_reader_new(char *uri, char *proxy, int proxy_port);
 
diff --git a/src/liboggplay/oggplay.c b/src/liboggplay/oggplay.c
index c71d639..8fa3b9e 100644
--- a/src/liboggplay/oggplay.c
+++ b/src/liboggplay/oggplay.c
@@ -48,7 +48,15 @@
 OggPlay *
 oggplay_new_with_reader(OggPlayReader *reader) {
 
-  OggPlay * me = (OggPlay *)malloc(sizeof(OggPlay));
+  OggPlay * me = NULL;
+
+  /* check whether the reader is valid. */
+  if (reader == NULL)
+    return NULL;
+
+  me = (OggPlay *)oggplay_malloc (sizeof(OggPlay));
+  if (me == NULL)
+	  return NULL;
 
   me->reader = reader;
   me->decode_data = NULL;
@@ -94,10 +102,20 @@ oggplay_initialise(OggPlay *me, int block) {
    * the main loop
    */
   me->oggz = oggz_new(OGGZ_READ | OGGZ_AUTO);
-  oggz_io_set_read(me->oggz, me->reader->io_read, me->reader);
-  oggz_io_set_seek(me->oggz, me->reader->io_seek, me->reader);
-  oggz_io_set_tell(me->oggz, me->reader->io_tell, me->reader);
-  oggz_set_read_callback(me->oggz, -1, oggplay_callback_predetected, me);
+  if (me->oggz == NULL)
+    return E_OGGPLAY_OGGZ_UNHAPPY;
+
+  if (oggz_io_set_read(me->oggz, me->reader->io_read, me->reader) != 0)
+    return E_OGGPLAY_OGGZ_UNHAPPY;
+
+  if (oggz_io_set_seek(me->oggz, me->reader->io_seek, me->reader) != 0)
+    return E_OGGPLAY_OGGZ_UNHAPPY;
+
+  if (oggz_io_set_tell(me->oggz, me->reader->io_tell, me->reader) != 0)
+    return E_OGGPLAY_OGGZ_UNHAPPY;
+
+  if (oggz_set_read_callback(me->oggz, -1, oggplay_callback_predetected, me))
+    return E_OGGPLAY_OGGZ_UNHAPPY;
 
   while (1) {
 
@@ -131,15 +149,20 @@ oggplay_initialise(OggPlay *me, int block) {
 OggPlay *
 oggplay_open_with_reader(OggPlayReader *reader) {
 
-  OggPlay *me = oggplay_new_with_reader(reader);
-
+  OggPlay *me = NULL;
   int r = E_OGGPLAY_TIMEOUT;
+
+  if ( (me = oggplay_new_with_reader(reader)) == NULL)
+    return NULL;
+
   while (r == E_OGGPLAY_TIMEOUT) {
     r = oggplay_initialise(me, 0);
   }
 
   if (r != E_OGGPLAY_OK) {
-    free(me);
+    /* in case of error close the OggPlay handle */
+    oggplay_close(me);
+
     return NULL;
   }
 
@@ -195,6 +218,7 @@ oggplay_set_callback_num_frames(OggPlay *me, int track, int frames) {
   me->callback_period = me->decode_data[track]->granuleperiod * frames;
   me->target = me->presentation_time + me->callback_period - 1;
 
+//  printf("targ: %lld, callback_per: %lld, prestime: %lld\n", me->target, me->callback_period,me->presentation_time );  
 
   return E_OGGPLAY_OK;
 
@@ -524,8 +548,10 @@ read_more_data:
 
       /*
        * ensure all tracks have their final data packet set to end_of_stream
+       * But skip doing this if we're shutting down --- me->buffer may not
+       * be in a safe state.
        */
-      if (me->buffer != NULL) {
+      if (me->buffer != NULL && !me->shutdown) {
         oggplay_buffer_set_last_data(me, me->buffer);
       }
 
@@ -594,17 +620,21 @@ oggplay_close(OggPlay *me) {
     me->reader->destroy(me->reader);
   }
 
-  for (i = 0; i < me->num_tracks; i++) {
-    oggplay_callback_shutdown(me->decode_data[i]);
+
+  if (me->decode_data) {
+    for (i = 0; i < me->num_tracks; i++) {
+      oggplay_callback_shutdown(me->decode_data[i]);
+    }
   }
 
-  oggz_close(me->oggz);
+  if (me->oggz)
+    oggz_close(me->oggz);
 
   if (me->buffer != NULL) {
     oggplay_buffer_shutdown(me, me->buffer);
   }
 
-  free(me);
+  oggplay_free(me);
 
   return E_OGGPLAY_OK;
 }
@@ -685,3 +715,4 @@ oggplay_media_finished_retrieving(OggPlay *me) {
   return me->reader->finished_retrieving(me->reader);
 
 }
+
diff --git a/src/liboggplay/oggplay_buffer.c b/src/liboggplay/oggplay_buffer.c
index e752f33..b116c7f 100644
--- a/src/liboggplay/oggplay_buffer.c
+++ b/src/liboggplay/oggplay_buffer.c
@@ -53,26 +53,43 @@
 OggPlayBuffer *
 oggplay_buffer_new_buffer(int size) {
 
-  OggPlayBuffer *buffer = 0;
+  OggPlayBuffer *buffer = NULL;
   if (size < 0) {
     size = OGGPLAY_DEFAULT_BUFFER_SIZE;
   }
 
-  buffer = (OggPlayBuffer*)malloc(sizeof (OggPlayBuffer));
+  buffer = (OggPlayBuffer*)oggplay_malloc(sizeof (OggPlayBuffer));
 
-  buffer->buffer_list = malloc(sizeof (void *) * size);
-  memset(buffer->buffer_list, 0, sizeof (void *) * size);
-  buffer->buffer_mirror = malloc(sizeof (void *) * size);
-  memset(buffer->buffer_mirror, 0, sizeof (void *) * size);
+  if (buffer == NULL)
+    return NULL;
+
+  buffer->buffer_list = oggplay_calloc(size, sizeof (void *));
+  if (buffer->buffer_list == NULL)
+    goto error;
+
+  buffer->buffer_mirror = oggplay_calloc(size, sizeof (void *));
+  if (buffer->buffer_mirror == NULL)
+    goto error;
 
   buffer->buffer_size = size;
   buffer->last_filled = -1;
   buffer->last_emptied = -1;
 
-  SEM_CREATE(buffer->frame_sem, size);
+  if (SEM_CREATE(buffer->frame_sem, size) != 0)
+    goto error;
 
   return buffer;
 
+error:
+  if (buffer->buffer_list != NULL)
+    oggplay_free (buffer->buffer_list);
+
+  if (buffer->buffer_mirror != NULL)
+    oggplay_free (buffer->buffer_mirror);
+
+  oggplay_free (buffer);
+
+  return NULL;
 }
 
 void
@@ -87,16 +104,16 @@ oggplay_buffer_shutdown(OggPlay *me, volatile OggPlayBuffer *vbuffer) {
     if (buffer->buffer_mirror[i] != NULL) {
       OggPlayCallbackInfo *ti = (OggPlayCallbackInfo *)buffer->buffer_mirror[i];
       for (j = 0; j < me->num_tracks; j++) {
-        free((ti + j)->records);
+        oggplay_free((ti + j)->records);
       }
-      free(ti);
+      oggplay_free(ti);
     }
   }
 
-  free(buffer->buffer_list);
-  free(buffer->buffer_mirror);
+  oggplay_free(buffer->buffer_list);
+  oggplay_free(buffer->buffer_mirror);
   SEM_CLOSE(buffer->frame_sem);
-  free(buffer);
+  oggplay_free(buffer);
 }
 
 int
@@ -147,6 +164,9 @@ oggplay_buffer_callback(OggPlay *me, int tracks,
   OggPlayCallbackInfo * ptr = track_info[0];
   int                   required;
 
+  if (me == NULL)
+    return -1;
+
   buffer = (OggPlayBuffer *)me->buffer;
 
   if (buffer == NULL) {
@@ -190,9 +210,9 @@ oggplay_buffer_callback(OggPlay *me, int tracks,
         /* free these here, because we couldn't free them in
          * oggplay_callback_info_destroy for buffer mode
          */
-        free((ti + i)->records);
+        oggplay_free((ti + i)->records);
       }
-      free(ti);
+      oggplay_free(ti);
       buffer->buffer_mirror[k] = NULL;
     }
   }
@@ -200,7 +220,10 @@ oggplay_buffer_callback(OggPlay *me, int tracks,
   /*
    * replace the decode_data buffer for the next callback
    */
-  me->callback_info = (OggPlayCallbackInfo *)calloc(me->num_tracks, sizeof (OggPlayCallbackInfo));
+  me->callback_info = 
+    (OggPlayCallbackInfo *)oggplay_calloc(me->num_tracks, sizeof (OggPlayCallbackInfo));
+  if (me->callback_info == NULL)
+    return -1;
 
   /*
    * fill both mirror and list, mirror first to avoid getting inconsistencies
@@ -256,7 +279,9 @@ oggplay_buffer_retrieve_next(OggPlay *me) {
   next_item = (OggPlayCallbackInfo*)buffer->buffer_list[next_loc];
   buffer->last_emptied = next_loc;
 
-  return_val = malloc(sizeof (OggPlayCallbackInfo *) * me->num_tracks);
+  return_val = oggplay_calloc(me->num_tracks, sizeof (OggPlayCallbackInfo *));
+  if (return_val == NULL)
+    return NULL;
 
   for (i = 0; i < me->num_tracks; i++) {
     return_val[i] = next_item + i;
@@ -289,7 +314,7 @@ oggplay_buffer_release(OggPlay *me, OggPlayCallbackInfo **track_info) {
     return E_OGGPLAY_UNINITIALISED;
   }
 
-  free(track_info);
+  oggplay_free(track_info);
 
   buffer->buffer_list[buffer->last_emptied] = NULL;
 
@@ -317,7 +342,8 @@ oggplay_use_buffer(OggPlay *me, int size) {
     return E_OGGPLAY_OK;
   }
 
-  me->buffer = oggplay_buffer_new_buffer(size);
+  if( (me->buffer = oggplay_buffer_new_buffer(size)) == NULL)
+    return E_OGGPLAY_OUT_OF_MEMORY;
 
   /*
    * if oggplay is already initialised, then prepare the buffer now
@@ -334,6 +360,9 @@ oggplay_buffer_prepare(OggPlay *me) {
 
   int i;
 
+  if (me == NULL)
+    return;
+
   oggplay_set_data_callback_force(me, &oggplay_buffer_callback, NULL);
 
   for (i = 0; i < me->num_tracks; i++) {
diff --git a/src/liboggplay/oggplay_buffer.h b/src/liboggplay/oggplay_buffer.h
index a356514..7a38976 100644
--- a/src/liboggplay/oggplay_buffer.h
+++ b/src/liboggplay/oggplay_buffer.h
@@ -39,6 +39,13 @@
 #ifndef __OGGPLAY_BUFFER_H__
 #define __OGGPLAY_BUFFER_H__
 
+/**
+ * Creates a new buffer with the given size. 
+ *
+ * @param size The number of frames the buffer can store. 
+ * @return A new OggPlayBuffer.
+ * @retval NULL in case of error. 
+ */
 OggPlayBuffer *
 oggplay_buffer_new_buffer(int size);
 
diff --git a/src/liboggplay/oggplay_callback.c b/src/liboggplay/oggplay_callback.c
index 6916838..5a4d1ba 100644
--- a/src/liboggplay/oggplay_callback.c
+++ b/src/liboggplay/oggplay_callback.c
@@ -315,6 +315,8 @@ oggplay_fish_sound_callback_floats(FishSound * fsound, float ** pcm,
      */
     oggplay_data_handle_audio_data(&(decoder->decoder), (short *)pcm, frames,
               sizeof(float));
+
+      return FISH_SOUND_STOP_ERR;
   }
 
   return FISH_SOUND_CONTINUE;
@@ -473,10 +475,17 @@ OggPlayCallbackFunctions callbacks[] = {
 OggPlayDecode *
 oggplay_initialise_decoder(OggPlay *me, int content_type, int serialno) {
 
-  ogg_int64_t   num;
-  ogg_int64_t   denom;
+  ogg_int64_t    num;
+  ogg_int64_t    denom;
+  OggPlayDecode *decoder = NULL;
+
+  if (me == NULL)
+    return NULL;
+
+  decoder = oggplay_malloc (callbacks[content_type].size);
 
-  OggPlayDecode * decoder = malloc (callbacks[content_type].size);
+  if (decoder == NULL)
+    return NULL;
 
   decoder->serialno = serialno;
   decoder->content_type = content_type;
@@ -538,8 +547,7 @@ oggplay_callback_shutdown(OggPlayDecode *decoder) {
 
   oggplay_data_shutdown_list(decoder);
 
-  free(decoder);
-
+  oggplay_free(decoder);
 }
 
 
@@ -595,11 +603,20 @@ oggplay_callback_predetected (OGGZ *oggz, ogg_packet *op, long serialno,
     }
   }
 
-  me->callback_info = realloc (me->callback_info,
+  me->callback_info = oggplay_realloc (me->callback_info,
                   sizeof (OggPlayCallbackInfo) * ++me->num_tracks);
-  me->decode_data = realloc (me->decode_data, sizeof (long) * me->num_tracks);
+  if (me->callback_info == NULL)
+    return -1;
+
+  me->decode_data = oggplay_realloc (me->decode_data, sizeof (long) * me->num_tracks);
+  if (me->decode_data == NULL)
+    return -1;
+
   me->decode_data[me->num_tracks - 1] = oggplay_initialise_decoder(me,
                                                       content_type, serialno);
+  if (me->decode_data[me->num_tracks - 1] == NULL)
+    return -1; 
+
   /*me->decode_data->callback_info = me->callback_info + (me->num_tracks - 1);*/
 
   /*
diff --git a/src/liboggplay/oggplay_callback.h b/src/liboggplay/oggplay_callback.h
index b6e1204..c6ddac1 100644
--- a/src/liboggplay/oggplay_callback.h
+++ b/src/liboggplay/oggplay_callback.h
@@ -45,6 +45,17 @@ oggplay_callback_predetected (OGGZ *oggz, ogg_packet *op, long serialno,
 void
 oggplay_process_leftover_packet(OggPlay *me);
 
+/**
+ * Create and initialise an OggPlayDecode handle.
+ *
+ *  
+ *
+ * @param me OggPlay 
+ * @param content_type 
+ * @param serialno
+ * @return A new OggPlayDecode handle
+ * @retval NULL in case of error.
+ */
 OggPlayDecode *
 oggplay_initialise_decoder(OggPlay *me, int content_type, int serialno);
 
diff --git a/src/liboggplay/oggplay_callback_info.c b/src/liboggplay/oggplay_callback_info.c
index 2363744..cbfb6ab 100644
--- a/src/liboggplay/oggplay_callback_info.c
+++ b/src/liboggplay/oggplay_callback_info.c
@@ -40,7 +40,7 @@
 
 #define M(x)  ((x) >> 32) 
 
-void _print_list(char *name, OggPlayDataHeader *p);
+extern void _print_list(char *name, OggPlayDataHeader *p);
 
 int
 oggplay_callback_info_prepare(OggPlay *me, OggPlayCallbackInfo ***info) {
@@ -56,7 +56,9 @@ oggplay_callback_info_prepare(OggPlay *me, OggPlayCallbackInfo ***info) {
   /*
    * allocate the structure for return to the user
    */
-  (*info) = malloc (me->num_tracks * sizeof (OggPlayCallbackInfo *));
+  (*info) = oggplay_calloc (me->num_tracks, sizeof (OggPlayCallbackInfo *));
+  if ((*info) == NULL)
+    return -1;
 
   /*
    * fill in each active track.  Leave gaps for inactive tracks.
@@ -128,7 +130,18 @@ oggplay_callback_info_prepare(OggPlay *me, OggPlayCallbackInfo ***info) {
     }
    
     /* null-terminate the record list for the python interface */
-    track_info->records = malloc ((count + 1) * sizeof (OggPlayDataHeader *));
+    track_info->records = oggplay_calloc ((count + 1), sizeof (OggPlayDataHeader *));
+    if (track_info->records == NULL)
+    {
+      for (i = 0; i < me->num_tracks; i++) {
+        if ((*info)[i]->records != NULL) 
+          oggplay_free ((*info)[i]->records);
+      }
+      oggplay_free (*info);
+      *info = NULL;
+      return -1;
+    }
+
     track_info->records[count] = NULL;
 
     track_info->available_records = count;
@@ -270,18 +283,20 @@ oggplay_callback_info_prepare(OggPlay *me, OggPlayCallbackInfo ***info) {
      * and callback creation
      */
     for (i = 0; i < me->num_tracks; i++) {
-      if ((*info)[i]->records != NULL) free((*info)[i]->records);
+      if ((*info)[i]->records != NULL) 
+        oggplay_free((*info)[i]->records);
     }
-    free(*info);
+    oggplay_free(*info);
     (*info) = NULL;
 
   }
 
   if (tcount == 0) {
     for (i = 0; i < me->num_tracks; i++) {
-      if ((*info)[i]->records != NULL) free((*info)[i]->records);
+      if ((*info)[i]->records != NULL) 
+        oggplay_free((*info)[i]->records);
     }
-    free(*info);
+    oggplay_free(*info);
     (*info) = NULL;
   }
 
@@ -299,10 +314,10 @@ oggplay_callback_info_destroy(OggPlay *me, OggPlayCallbackInfo **info) {
   for (i = 0; i < me->num_tracks; i++) {
     p = info[i];
     if (me->buffer == NULL && p->records != NULL)
-      free(p->records);
+      oggplay_free(p->records);
   }
 
-  free(info);
+  oggplay_free(info);
 
 }
 
diff --git a/src/liboggplay/oggplay_data.c b/src/liboggplay/oggplay_data.c
index 3055f0e..0bf7651 100644
--- a/src/liboggplay/oggplay_data.c
+++ b/src/liboggplay/oggplay_data.c
@@ -157,7 +157,7 @@ oggplay_data_add_to_list (OggPlayDecode *decode, OggPlayDataHeader *data) {
       if (untimed->presentation_time >= decode->player->presentation_time) {
         oggplay_data_add_to_list_front(decode, untimed);
       } else {
-        free(untimed);
+        oggplay_free(untimed);
       }
 
     }
@@ -188,7 +188,7 @@ oggplay_data_free_list(OggPlayDataHeader *list) {
   while (list != NULL) {
     p = list;
     list = list->next;
-    free(p);
+    oggplay_free(p);
   }
 }
 
@@ -236,13 +236,13 @@ oggplay_data_clean_list (OggPlayDecode *decode) {
         decode->data_list = decode->data_list->next;
         if (decode->data_list == NULL)
           decode->end_of_data_list = NULL;
-        free (header);
+        oggplay_free (header);
         header = decode->data_list;
       } else {
         if (header->next == NULL)
           decode->end_of_data_list = p;
         p->next = header->next;
-        free (header);
+        oggplay_free (header);
         header = p->next;
       }
     } else {
@@ -271,12 +271,15 @@ oggplay_data_handle_audio_data (OggPlayDecode *decode, void *data,
       int samples, int samplesize) {
 
   int                   num_channels;
-  OggPlayAudioRecord  * record;
+  OggPlayAudioRecord  * record = NULL;
 
   num_channels = ((OggPlayAudioDecode *)decode)->sound_info.channels;
-  record = (OggPlayAudioRecord*)calloc(sizeof(OggPlayAudioRecord) +
+  record = (OggPlayAudioRecord*)oggplay_calloc(sizeof(OggPlayAudioRecord) +
                   samples * samplesize * num_channels, 1);
 
+  if (record == NULL)
+    return;
+
   oggplay_data_initialise_header(decode, &(record->header));
 
   record->header.samples_in_record = samples;
@@ -295,10 +298,14 @@ void
 oggplay_data_handle_cmml_data(OggPlayDecode *decode, unsigned char *data,
                 int size) {
 
-  OggPlayTextRecord * record;
+  OggPlayTextRecord * record = NULL;
 
   record =
-      (OggPlayTextRecord*)calloc (sizeof(OggPlayTextRecord) + size + 1, 1);
+      (OggPlayTextRecord*)oggplay_calloc (sizeof(OggPlayTextRecord) + size + 1, 1);
+
+  if (record == NULL)
+    return;
+
   oggplay_data_initialise_header(decode, &(record->header));
 
   record->header.samples_in_record = 1;
@@ -336,7 +343,11 @@ oggplay_data_handle_theora_frame (OggPlayTheoraDecode *decode,
    * we need to set the output strides to the input widths because we are
    * trying not to pass negative output stride issues on to the poor user.
    */
-  record = (OggPlayVideoRecord*)malloc (size);
+  record = (OggPlayVideoRecord*)oggplay_malloc (size);
+
+  if (record == NULL)
+    return;
+
   record->header.samples_in_record = 1;
   data = &(record->data);
   oggplay_data_initialise_header((OggPlayDecode *)decode, &(record->header));
@@ -379,9 +390,13 @@ oggplay_data_handle_kate_data(OggPlayKateDecode *decode, const kate_event *ev) {
 
   // TODO: should be able to send the data rendered as YUV data, but just text for now
 
-  OggPlayTextRecord * record;
+  OggPlayTextRecord * record = NULL;
+
+  record = (OggPlayTextRecord*)oggplay_calloc (sizeof(OggPlayTextRecord) + ev->len0, 1);
+  
+  if (record = NULL)
+    return;
 
-  record = (OggPlayTextRecord*)calloc (sizeof(OggPlayTextRecord) + ev->len0, 1);
   oggplay_data_initialise_header(&decode->decoder, &(record->header));
 
   //record->header.presentation_time = (ogg_int64_t)(ev->start_time*1000);
diff --git a/src/liboggplay/oggplay_file_reader.c b/src/liboggplay/oggplay_file_reader.c
index 789049f..1ec0f42 100644
--- a/src/liboggplay/oggplay_file_reader.c
+++ b/src/liboggplay/oggplay_file_reader.c
@@ -76,7 +76,7 @@ oggplay_file_reader_destroy(OggPlayReader * opr) {
   me = (OggPlayFileReader *)opr;
 
   fclose(me->file);
-  free(me);
+  oggplay_free(me);
 
   return E_OGGPLAY_OK;
 }
@@ -135,7 +135,10 @@ oggplay_file_reader_io_tell(void * user_handle) {
 OggPlayReader *
 oggplay_file_reader_new(char *file_name) {
 
-  OggPlayFileReader * me = malloc (sizeof (OggPlayFileReader));
+  OggPlayFileReader * me = oggplay_malloc (sizeof (OggPlayFileReader));
+
+  if (me == NULL)
+    return NULL;
 
   me->current_position = 0;
   me->file_name = file_name;
diff --git a/src/liboggplay/oggplay_private.h b/src/liboggplay/oggplay_private.h
index c4743e6..7e5b9de 100644
--- a/src/liboggplay/oggplay_private.h
+++ b/src/liboggplay/oggplay_private.h
@@ -240,47 +240,15 @@ typedef struct {
   int size;
 } OggPlayCallbackFunctions;
 
+/* Allocate and free dynamic memory used by ogg.
+ * By default they are the ones from stdlib */
+#define oggplay_malloc _ogg_malloc
+#define oggplay_calloc _ogg_calloc
+#define oggplay_realloc _ogg_realloc
+#define oggplay_free _ogg_free
+
 #include "oggplay_callback.h"
 #include "oggplay_data.h"
 #include "oggplay_buffer.h"
 
-#if 0
-static inline void _free(void *x) {
-  printf("%p\n", x);
-  free(x);
-}
-
-static inline void *_malloc(int s) {
-  void *x;
-  printf("%d ", s);
-  x = malloc(s);
-  printf("%p\n", x);
-  return x;
-}
-
-static inline void *_realloc(void *x, int s) {
-  void *y;
-  printf("%p %d ", x, s);
-  y = realloc(x, s);
-  printf("%p\n", y);
-  return y;
-}
-
-static inline void *_calloc(int n, int s) {
-  void *x;
-  printf("%d %d ", n, s);
-  x = calloc(n, s);
-  printf("%p\n", x);
-  return x;
-}
-
-#define free(x) {printf("FREE %s %d ", __FILE__, __LINE__); _free(x);}
-#define malloc(s) (printf("MALLOC %s %d ", __FILE__, __LINE__), \
-    _malloc(s))
-#define realloc(x, s) (printf("REALLOC %s %d ", __FILE__, __LINE__), \
-    _realloc(x, s))
-#define calloc(n, s) (printf("CALLOC %s %d ", __FILE__, __LINE__),  \
-    _calloc(n, s))
-#endif
-
 #endif
diff --git a/src/liboggplay/oggplay_seek.c b/src/liboggplay/oggplay_seek.c
index 415ce0f..f93552f 100644
--- a/src/liboggplay/oggplay_seek.c
+++ b/src/liboggplay/oggplay_seek.c
@@ -87,13 +87,19 @@ oggplay_seek_cleanup(OggPlay* me, ogg_int64_t milliseconds)
   OggPlayDataHeader  ** end_of_list_p;
   int                   i;
 
+  if (me  == NULL)
+    return;
+
   /*
    * first, create a trash object to store the context that we want to
    * delete but can't until the presentation thread is no longer using it -
    * this will occur as soon as the thread calls oggplay_buffer_release_next
    */
 
-  trash = calloc(sizeof(OggPlaySeekTrash), 1);
+  trash = oggplay_calloc(1, sizeof(OggPlaySeekTrash));
+
+  if (trash == NULL)
+    return;
 
   /*
    * store the old buffer in it next.
@@ -106,6 +112,11 @@ oggplay_seek_cleanup(OggPlay* me, ogg_int64_t milliseconds)
    */
   me->buffer = oggplay_buffer_new_buffer(me->buffer->buffer_size);
 
+  if (me->buffer == NULL)
+  {
+    return;
+  }
+
   /*
    * strip all of the data packets out of the streams and put them into the
    * trash.  We can free the untimed packets immediately - they are USELESS
@@ -152,12 +163,12 @@ oggplay_take_out_trash(OggPlay *me, OggPlaySeekTrash *trash) {
     oggplay_buffer_shutdown(me, trash->old_buffer);
     oggplay_data_free_list(trash->old_data);
     if (p != NULL) {
-      free(p);
+      oggplay_free(p);
     }
     p = trash;
   }
 
   if (p != NULL) {
-    free(p);
+    oggplay_free(p);
   }
 }
diff --git a/src/liboggplay/oggplay_tcp_reader.c b/src/liboggplay/oggplay_tcp_reader.c
index c2d55fb..e40d2da 100644
--- a/src/liboggplay/oggplay_tcp_reader.c
+++ b/src/liboggplay/oggplay_tcp_reader.c
@@ -148,13 +148,21 @@ oggplay_create_socket() {
   return sock;
 }
 
-/*
- * this function guarantees it will return malloced versions of host and
+/**
+ * This function guarantees it will return malloced versions of host and
  * path
+ *
+ * @param location Location of the Ogg content
+ * @param proxy The proxy if there's any.
+ * @param proxy_port The port of the proxy if there's any.
+ * @param host The host to connect to; using proxy if set. 
+ * @param port The port to connect to;
+ * @param path The path where the content resides on the server.  
+ * @retval -1 in case of error, 0 otherwise. 
  */
-void
+int
 oggplay_hostname_and_path(char *location, char *proxy, int proxy_port,
-                                  char **host, int *port, char **path) {
+                          char **host, int *port, char **path) {
 
 
   char  * colon;
@@ -163,10 +171,15 @@ oggplay_hostname_and_path(char *location, char *proxy, int proxy_port,
 
   /* if we have a proxy installed this is all dead simple */
   if (proxy != NULL) {
-    *host = strdup(proxy);
+    if ((*host = strdup(proxy)) == NULL)
+      goto error;
+
     *port = proxy_port;
-    *path = strdup(location);
-    return;
+
+    if ((*path = strdup(location)) == NULL)
+      goto error;
+
+    return 0;
   }
 
   /* find start_pos */
@@ -181,10 +194,15 @@ oggplay_hostname_and_path(char *location, char *proxy, int proxy_port,
    * if both are null, then just set the simple defaults and return
    */
   if (colon == NULL && slash == NULL) {
-    *host = strdup(location);
+    if ((*host = strdup(location)) == NULL)
+      goto error;
+
     *port = 80;
-    *path = strdup("/");
-    return;
+
+    if ((*path = strdup("/") == NULL))
+      goto error;
+
+    return 0;
   }
 
   /*
@@ -208,16 +226,29 @@ oggplay_hostname_and_path(char *location, char *proxy, int proxy_port,
     end_of_host = slash;
   }
 
-  *host = strdup(location);
+  if ((*host = strdup(location)) == NULL)
+    goto error;
+  
   (*host)[end_of_host - location] = '\0';
 
   if (slash == NULL) {
-    *path = strdup("/");
-    return;
+    if ((*path = strdup("/")) == NULL)
+      goto error;
+
+    return 0;
   }
 
-  *path = strdup(slash);
+  if ((*path = strdup(slash)) == NULL)
+    goto error;
+
+  return 0;
+
+error:
+  /* there has been an error while copying strings... */
+  if (*host != NULL)
+    oggplay_free(*host);
 
+  return -1;
 }
 
 OggPlayErrorCode
@@ -303,8 +334,9 @@ oggplay_tcp_reader_initialise(OggPlayReader * opr, int block) {
   /*
    * Extract the host name and the path from the location.
    */
-  oggplay_hostname_and_path(me->location, me->proxy, me->proxy_port,
-                              &host, &port, &path);
+  if (oggplay_hostname_and_path(me->location, me->proxy, me->proxy_port,
+                              &host, &port, &path) != 0)
+    return E_OGGPLAY_OUT_OF_MEMORY;
 
 
   /*
@@ -320,8 +352,8 @@ oggplay_tcp_reader_initialise(OggPlayReader * opr, int block) {
 
   he = gethostbyname(host);
 
-  free(host);
-  free(path);
+  oggplay_free(host);
+  oggplay_free(path);
 
   if (he == NULL) {
     printf("Host not found\n");
@@ -374,7 +406,10 @@ oggplay_tcp_reader_initialise(OggPlayReader * opr, int block) {
     int found_http_response = 0;
 
     if (me->buffer == NULL) {
-      me->buffer = (unsigned char*)malloc(TCP_READER_MAX_IN_MEMORY);
+      me->buffer = (unsigned char*)oggplay_malloc(TCP_READER_MAX_IN_MEMORY);
+      if (me->buffer == NULL)
+        return E_OGGPLAY_OUT_OF_MEMORY;
+
       me->buffer_size = TCP_READER_MAX_IN_MEMORY;
       me->amount_in_memory = 0;
     }
@@ -514,12 +549,12 @@ oggplay_tcp_reader_destroy(OggPlayReader * opr) {
 #endif
   }
 
-  free(me->buffer);
-  free(me->location);
+  if (me->buffer != NULL) oggplay_free(me->buffer);
+  if (me->location != NULL) oggplay_free(me->location);
   if (me->backing_store != NULL) {
     fclose(me->backing_store);
   }
-  free(me);
+  oggplay_free(me);
   return E_OGGPLAY_OK;
 }
 
@@ -661,14 +696,22 @@ oggplay_tcp_reader_io_tell(void * user_handle) {
 OggPlayReader *
 oggplay_tcp_reader_new(char *location, char *proxy, int proxy_port) {
 
-  OggPlayTCPReader * me = (OggPlayTCPReader *)malloc (sizeof (OggPlayTCPReader));
+  OggPlayTCPReader * me = (OggPlayTCPReader *)oggplay_malloc (sizeof (OggPlayTCPReader));
+
+  if (me == NULL)
+    return NULL;
 
   me->state = OTRS_UNINITIALISED;
   me->socket = INVALID_SOCKET;
   me->buffer = NULL;
   me->buffer_size = 0;
   me->current_position = 0;
-  me->location = strdup(location);
+  /* if there's not enough memory to copy the URI cancel the initialisation */
+  if ( (me->location = strdup(location)) == NULL)
+  {
+    oggplay_tcp_reader_destroy ((OggPlayReader*)me);
+    return NULL;
+  }
   me->amount_in_memory = 0;
   me->backing_store = NULL;
   me->stored_offset = 0;
